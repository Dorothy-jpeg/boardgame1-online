<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Board Game - Real-Time Multiplayer</title>
    <!-- Add Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        /* ... (ALL YOUR CSS STYLES REMAIN THE SAME - TOO LONG TO REPEAT) ... */
    </style>
</head>
<body>

<!-- NOTIFICATION CONTAINER -->
<div class="notification-container" id="notificationContainer"></div>

<!-- MULTIPLAYER OVERLAY -->
<div id="multiplayerOverlay" class="overlay multiplayer-overlay" style="display: none;">
    <!-- ... (MULTIPLAYER HTML REMAINS THE SAME) ... -->
</div>

<div id="board">
    <!-- MULTIPLAYER BUTTON -->
    <button class="multiplayer-btn" onclick="showMultiplayerMenu()" id="multiplayerButton">
        üåê Online Play
    </button>

    <!-- PLAYER 2 AREA -->
    <div class="player-area" id="player2Area">
        <!-- ... (PLAYER 2 HTML REMAINS THE SAME) ... -->
    </div>

    <!-- PLAYER 1 AREA -->
    <div class="player-area" id="player1Area">
        <!-- ... (PLAYER 1 HTML REMAINS THE SAME) ... -->
    </div>

    <button id="shopButton" onclick="openShop()">üõçÔ∏è Shop</button>
</div>

<!-- SHOP OVERLAY -->
<div id="shopOverlay" class="overlay" style="align-items: stretch;">
    <div id="shopWindow">
        <div style="display:flex; justify-content:space-between;">
            <h2>Card Shop</h2> 
            <button onclick="closeShop()" style="background:#c00">Close</button>
        </div>
        
        <!-- CATEGORY BUTTONS -->
        <div class="category-buttons">
            <button class="category-btn active" onclick="filterShopCards('all', event)">All Cards</button>
            <button class="category-btn" onclick="filterShopCards('avatar', event)">Avatar</button>
            <button class="category-btn" onclick="filterShopCards('magic', event)">Magic</button>
            <button class="category-btn" onclick="filterShopCards('construct', event)">Construct</button>
            <button class="category-btn" onclick="filterShopCards('life', event)">Life</button>
        </div>
        
        <!-- SPECIAL BUTTONS FOR LIFE CATEGORY -->
        <div id="lifeCategoryButtons" style="display: none; gap: 10px; margin-bottom: 15px;">
            <button class="add-to-life-btn" onclick="addToLifeZone(1)">Add to P1 Life Zone</button>
            <button class="add-to-life-btn" onclick="addToLifeZone(2)">Add to P2 Life Zone</button>
        </div>
        
        <div id="shopCards"></div>
    </div>
</div>

<!-- QUANTITY SELECTOR OVERLAY -->
<div id="quantityOverlay" class="overlay">
    <!-- ... (QUANTITY SELECTOR HTML REMAINS THE SAME) ... -->
</div>

<!-- ZOOM OVERLAY -->
<div id="zoomOverlay" class="overlay">
    <!-- ... (ZOOM OVERLAY HTML REMAINS THE SAME) ... -->
</div>

<!-- CONFIRM DELETE OVERLAY -->
<div id="confirmDeleteOverlay" class="confirm-delete-overlay">
    <!-- ... (CONFIRM DELETE HTML REMAINS THE SAME) ... -->
</div>

<!-- HAND OVERLAY -->
<div id="handOverlay" class="overlay">
    <!-- ... (HAND OVERLAY HTML REMAINS THE SAME) ... -->
</div>

<!-- DECK OVERLAY -->
<div id="deckOverlay" class="overlay">
    <!-- ... (DECK OVERLAY HTML REMAINS THE SAME) ... -->
</div>

<!-- GRAVEYARD OVERLAY -->
<div id="graveyardOverlay" class="overlay">
    <!-- ... (GRAVEYARD OVERLAY HTML REMAINS THE SAME) ... -->
</div>

<script>
// ============================================================================
// FIREBASE CONFIGURATION
// ============================================================================
const firebaseConfig = {
  apiKey: "AIzaSyCWJUqRC00L1h7W8BgDmP8UjVHXbyaJaas",
  authDomain: "boardgame2-95da5.firebaseapp.com",
  databaseURL: "https://boardgame2-95da5-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "boardgame2-95da5",
  storageBucket: "boardgame2-95da5.firebasestorage.app",
  messagingSenderId: "196618431674",
  appId: "1:196618431674:web:fc4898cb08f60420b26683"
};

// Initialize Firebase
let database;
try {
  firebase.initializeApp(firebaseConfig);
  database = firebase.database();
  console.log("‚úÖ Firebase initialized successfully!");
} catch (error) {
  console.error("‚ùå Firebase error:", error);
}

// ============================================================================
// NOTIFICATION SYSTEM
// ============================================================================
function showNotification(title, message, type = 'info', duration = 3000) {
    const container = document.getElementById('notificationContainer');
    if (!container) return;
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    
    const icon = type === 'success' ? '‚úì' : 
                 type === 'warning' ? '‚ö†' : 
                 type === 'error' ? '‚úó' : 
                 '‚Ñπ';
    
    notification.innerHTML = `
        <button class="notification-close" onclick="this.parentElement.classList.add('fade-out')">√ó</button>
        <div class="notification-title">${icon} ${title}</div>
        <div class="notification-message">${message}</div>
    `;
    
    container.appendChild(notification);
    
    if (duration > 0) {
        setTimeout(() => {
            notification.classList.add('fade-out');
            setTimeout(() => notification.remove(), 300);
        }, duration);
    }
}

// ============================================================================
// MANUAL CARD DATABASE
// ============================================================================
const MANUAL_CARD_DATABASE = [
    // === AVATAR CARDS ===
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896378/1avatar_ampfsg.png",
        category: "avatar",
        name: "Avatar 1",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896476/2avatar_jig21h.png",
        category: "avatar",
        name: "Avatar 2",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896612/3avatar_a34wih.png",
        category: "avatar",
        name: "Avatar 3",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896764/4avatar_bq6upr.png",
        category: "avatar",
        name: "Avatar 4",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896795/5avatar_dfqmmy.png",
        category: "avatar",
        name: "Avatar 5",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896830/6avatar_egsbw9.png",
        category: "avatar",
        name: "Avatar 6",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896834/7avatar_n1dmza.png",
        category: "avatar",
        name: "Avatar 7",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896882/8avatar_vrfyxk.png",
        category: "avatar",
        name: "Avatar 8",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896889/9avatar_vqavng.png",
        category: "avatar",
        name: "Avatar 9",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896289/10avatar_fervf8.png",
        category: "avatar",
        name: "Avatar 10",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896294/11avatar_ovywr4.png",
        category: "avatar",
        name: "Avatar 11",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896300/12avatar_ebgvni.png",
        category: "avatar",
        name: "Avatar 12",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896307/13avatar_lbis7h.png",
        category: "avatar",
        name: "Avatar 13",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896315/14avatar_ext6hu.png",
        category: "avatar",
        name: "Avatar 14",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896325/15avatar_uuejra.png",
        category: "avatar",
        name: "Avatar 15",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896351/16avatar_wxbsyh.png",
        category: "avatar",
        name: "Avatar 16",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896356/17avatar_whvgjr.png",
        category: "avatar",
        name: "Avatar 17",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896372/18avatar_n7s911.png",
        category: "avatar",
        name: "Avatar 18",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896377/19avatar_b9vg4t.png",
        category: "avatar",
        name: "Avatar 19",
        color: "#4A90E2"
    },
    {
        image: "https://res.cloudinary.com/dlkpniqxp/image/upload/v1765896386/20avatar_nycr0k.png",
        category: "avatar",
        name: "Avatar 20",
        color: "#4A90E2"
    },
    
    // === MAGIC CARDS ===
    // Add your magic cards here when ready
    
    // === CONSTRUCT CARDS ===
    // Add your construct cards here when ready
    
    // === LIFE CARDS ===
    // Add your life cards here when ready
];

// ============================================================================
// CARD CATEGORIES CONFIGURATION
// ============================================================================
const CARD_CATEGORIES = {
    avatar: {
        name: "Avatar",
        color: "#4A90E2"
    },
    magic: {
        name: "Magic",
        color: "#9013FE"
    },
    construct: {
        name: "Construct",
        color: "#F5A623"
    },
    life: {
        name: "Life",
        color: "#7ED321"
    }
};

// ============================================================================
// MULTIPLAYER STATE
// ============================================================================
let multiplayer = {
    gameId: null,
    playerId: null,
    playerNumber: null,
    isHost: false,
    gameRef: null,
    boardStateRef: null,
    isSyncing: false
};

// ============================================================================
// GAME STATE
// ============================================================================
let decks = { 1: [], 2: [] };
let hands = { 1: [], 2: [] };
let graveyards = { 1: [], 2: [] };
let boardCards = [];
let counterTokens = { 1: [], 2: [] };
let lifeZones = { 1: Array(5).fill(null), 2: Array(5).fill(null) };
let currentZoomImage = "";
let currentZoomSource = null;
let cardToDelete = null;

let dragState = {
    isDragging: false,
    card: null,
    originalCard: null,
    originalParent: null,
    originalLeft: 0,
    originalTop: 0,
    ghostCard: null,
    startX: 0,
    startY: 0,
    mouseDownTime: 0,
    clickThreshold: 200,
    lastDraggedCard: null,
    draggingToken: false
};

let quantitySelectorState = {
    image: "",
    category: "",
    quantity: 1
};

let currentShopCategory = 'all';
let currentShopImage = null;

const TOKEN_COLORS = {
    1: ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3'],
    2: ['#ff9a76', '#a8e6cf', '#ffd3b6', '#a8d8ea']
};

const TOKEN_LABELS = ['Health', 'Mana', 'Attack', 'Defense'];

let allShopCards = [];

// ============================================================================
// IMAGE LOADING HELPER
// ============================================================================
function loadImageWithFallback(element, imageUrl, fallbackColor = "#555") {
    const img = new Image();
    
    img.onload = function() {
        if (element) {
            element.style.backgroundImage = `url('${imageUrl}')`;
            element.style.backgroundSize = 'cover';
            element.style.backgroundPosition = 'center';
            element.style.backgroundColor = 'transparent';
        }
    };
    
    img.onerror = function() {
        console.warn('Failed to load image:', imageUrl);
        if (element) {
            element.style.backgroundImage = 'none';
            element.style.backgroundColor = fallbackColor;
        }
    };
    
    img.src = imageUrl;
}

// ============================================================================
// CARD MANAGEMENT SYSTEM
// ============================================================================
function addCardToDatabase(imageUrl, category, name = "") {
    let color = "#555";
    switch(category) {
        case 'avatar': color = "#4A90E2"; break;
        case 'magic': color = "#9013FE"; break;
        case 'construct': color = "#F5A623"; break;
        case 'life': color = "#7ED321"; break;
    }
    
    const newCard = {
        image: imageUrl,
        category: category,
        name: name || `Card ${allShopCards.length + 1}`,
        color: color
    };
    
    MANUAL_CARD_DATABASE.push(newCard);
    allShopCards.push(newCard);
    
    console.log("‚úÖ Card added:", newCard);
    showNotification("Card Added", `Added ${name || 'new card'} to database`, 'success', 2000);
    
    if (document.getElementById("shopOverlay").style.display === "flex") {
        filterShopCards(currentShopCategory);
    }
    
    return newCard;
}

// ============================================================================
// SHOP FUNCTIONS
// ============================================================================
function setupShop() {
    console.log("Setting up shop with manual card database...");
    
    allShopCards = [...MANUAL_CARD_DATABASE];
    
    console.log(`Loaded ${allShopCards.length} cards from database`);
    
    filterShopCards('all');
    
    if (allShopCards.length > 0) {
        showNotification(
            "Shop Ready", 
            `Loaded ${allShopCards.length} cards.`, 
            'success', 
            3000
        );
    }
}

function filterShopCards(category, event) {
    currentShopCategory = category;
    
    document.querySelectorAll('.category-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    if (event && event.target) {
        event.target.classList.add('active');
    } else if (document.querySelector('.category-btn')) {
        document.querySelector('.category-btn').classList.add('active');
    }
    
    const lifeButtons = document.getElementById('lifeCategoryButtons');
    if (category === 'life') {
        lifeButtons.style.display = 'flex';
    } else {
        lifeButtons.style.display = 'none';
    }
    
    const container = document.getElementById("shopCards");
    container.innerHTML = "";
    
    const filteredCards = category === 'all' 
        ? allShopCards 
        : allShopCards.filter(card => card.category === category);
    
    if (filteredCards.length === 0) {
        const emptyMessage = document.createElement('div');
        emptyMessage.style.textAlign = 'center';
        emptyMessage.style.padding = '40px';
        emptyMessage.style.color = '#888';
        
        if (category === 'all') {
            emptyMessage.innerHTML = `
                <h3>No Cards Yet</h3>
                <p>Add cards using the console:</p>
                <div style="background:#222; padding:10px; border-radius:5px; margin:10px; font-family:monospace;">
                    addCardToDatabase("https://res.cloudinary.com/dlkpniqxp/image/upload/...", "avatar", "Card Name")
                </div>
            `;
        } else {
            emptyMessage.innerHTML = `
                <h3>No ${category} Cards</h3>
                <p>No ${category} cards in database yet.</p>
            `;
        }
        
        container.appendChild(emptyMessage);
        return;
    }
    
    filteredCards.forEach((cardData, index) => {
        const card = document.createElement("div");
        card.className = "hand-display-card shop-card";
        card.dataset.index = index;
        
        loadImageWithFallback(card, cardData.image, cardData.color);
        
        card.style.borderColor = cardData.color;
        card.style.borderWidth = "3px";
        
        const badge = document.createElement("div");
        badge.style.position = "absolute";
        badge.style.top = "5px";
        badge.style.right = "5px";
        badge.style.background = cardData.color;
        badge.style.color = "white";
        badge.style.padding = "2px 6px";
        badge.style.borderRadius = "10px";
        badge.style.fontSize = "10px";
        badge.style.fontWeight = "bold";
        badge.textContent = cardData.category.charAt(0).toUpperCase();
        card.appendChild(badge);
        
        if (cardData.name) {
            const nameLabel = document.createElement("div");
            nameLabel.style.position = "absolute";
            nameLabel.style.bottom = "5px";
            nameLabel.style.left = "0";
            nameLabel.style.right = "0";
            nameLabel.style.background = "rgba(0,0,0,0.7)";
            nameLabel.style.color = "white";
            nameLabel.style.padding = "3px";
            nameLabel.style.fontSize = "10px";
            nameLabel.style.textAlign = "center";
            nameLabel.style.borderRadius = "0 0 4px 4px";
            nameLabel.textContent = cardData.name.length > 15 
                ? cardData.name.substring(0, 12) + "..." 
                : cardData.name;
            card.appendChild(nameLabel);
        }
        
        card.title = `${cardData.name || 'Unnamed Card'}\nCategory: ${cardData.category}\nClick to add to deck`;
        
        if (category === 'life') {
            card.onclick = () => {
                currentShopImage = cardData.image;
                document.querySelectorAll('.shop-card').forEach(c => {
                    c.style.boxShadow = 'none';
                });
                card.style.boxShadow = `0 0 15px ${cardData.color}`;
                showNotification(
                    "Card Selected", 
                    `Selected ${cardData.name}. Now click "Add to P1 Life Zone" or "Add to P2 Life Zone"`, 
                    'info', 
                    3000
                );
            };
        } else {
            card.onclick = () => openQuantitySelector(cardData.image, cardData.category);
        }
        
        container.appendChild(card);
    });
}

function openShop() {
    document.getElementById("shopOverlay").style.display = "flex";
    currentShopImage = null;
    document.querySelectorAll('.shop-card').forEach(c => {
        c.style.boxShadow = 'none';
    });
}

function closeShop() {
    document.getElementById("shopOverlay").style.display = "none";
}

function openQuantitySelector(image, category) {
    quantitySelectorState = {
        image: image,
        category: category,
        quantity: 1
    };
    
    const preview = document.getElementById('quantityCardPreview');
    loadImageWithFallback(preview, image, "#555");
    document.getElementById('quantityDisplay').textContent = '1';
    document.getElementById('quantityOverlay').style.display = 'flex';
}

function changeQuantity(amount) {
    const newQty = quantitySelectorState.quantity + amount;
    if (newQty >= 1 && newQty <= 99) {
        quantitySelectorState.quantity = newQty;
        document.getElementById('quantityDisplay').textContent = newQty;
    }
}

function closeQuantitySelector() {
    document.getElementById('quantityOverlay').style.display = 'none';
}

function addMultipleToDeck(player) {
    const { image, quantity } = quantitySelectorState;
    
    if (image && quantity > 0) {
        let categoryColor = "#555";
        for (const [categoryId, category] of Object.entries(CARD_CATEGORIES)) {
            if (categoryId === quantitySelectorState.category) {
                categoryColor = category.color;
                break;
            }
        }
        
        for (let i = 0; i < quantity; i++) {
            const cardId = `card_${Date.now()}_${Math.random().toString(36).substr(2, 9)}_${i}`;
            decks[player].push({ 
                image: image, 
                id: cardId,
                color: categoryColor
            });
        }
        
        updateCounters();
        updateDeckVisual(player);
        closeQuantitySelector();
        
        showNotification("Cards Added to Deck", `${quantity} card(s) added to Player ${player}'s deck!`, 'success', 3000);
        
        if (multiplayer.gameId) {
            setTimeout(() => {
                syncGameStateToFirebase();
            }, 100);
        }
    }
}

// ============================================================================
// CORE GAME FUNCTIONS
// ============================================================================
function updateDeckVisual(player) {
    const deckZone = document.getElementById(`deck${player}`);
    const deckCount = decks[player].length;
    const deckStack = deckZone.querySelector('.deck-card-stack');
    
    document.getElementById(`deckCount${player}`).textContent = deckCount;
    
    if (deckCount === 0) {
        deckZone.classList.add('empty');
        document.getElementById(`shuffleBtn${player}`).disabled = true;
        document.getElementById(`openBtn${player}`).disabled = true;
    } else {
        deckZone.classList.remove('empty');
        document.getElementById(`shuffleBtn${player}`).disabled = false;
        document.getElementById(`openBtn${player}`).disabled = false;
        
        deckStack.innerHTML = '';
        const layers = Math.min(5, deckCount);
        for (let i = 0; i < layers; i++) {
            const layer = document.createElement('div');
            layer.className = 'deck-card-layer';
            deckStack.appendChild(layer);
        }
    }
}

function drawCardWithAnimation(player) {
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only draw from your own deck", 'error');
        return;
    }
    
    if (decks[player].length === 0) {
        showNotification("Deck Empty", "Open Shop to add cards to your deck!", 'warning');
        return;
    }
    
    const cardData = decks[player].shift();
    hands[player].push(cardData);
    updateCounters();
    updateDeckVisual(player);
    
    showNotification("Card Drawn", `Player ${player} drew 1 card`, 'success');
    
    if (multiplayer.gameId) {
        setTimeout(() => {
            syncGameStateToFirebase();
        }, 100);
    }
}

function shuffleDeckWithAnimation(player) {
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only shuffle your own deck", 'error');
        return;
    }
    
    if (decks[player].length === 0) {
        showNotification("Deck Empty", "No cards to shuffle!", 'warning');
        return;
    }
    
    decks[player].sort(() => Math.random() - 0.5);
    updateDeckVisual(player);
    
    showNotification("Deck Shuffled", `Player ${player}'s deck shuffled`, 'success');
    
    if (multiplayer.gameId) {
        setTimeout(() => {
            syncGameStateToFirebase();
        }, 100);
    }
}

function openFromDeck(player) {
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only open from your own deck", 'error');
        return;
    }
    
    if (decks[player].length === 0) {
        showNotification("Deck Empty", "No cards in deck!", 'warning');
        return;
    }
    
    const cardData = decks[player].shift();
    createBoardCard(cardData, player);
    updateCounters();
    updateDeckVisual(player);
    
    showNotification("Card Opened", `Player ${player} opened a card`, 'success');
    
    if (multiplayer.gameId) {
        setTimeout(() => {
            syncGameStateToFirebase();
        }, 100);
    }
}

function createBoardCard(cardData, player) {
    const cardId = cardData.id || `board_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const boardCard = document.createElement("div");
    boardCard.className = "board-card";
    boardCard.id = cardId;
    
    loadImageWithFallback(boardCard, cardData.image, cardData.color);
    
    if (cardData.color) {
        boardCard.style.borderColor = cardData.color;
        boardCard.style.borderWidth = "3px";
    }
    
    const playerArea = document.getElementById(`player${player}Area`);
    const rect = playerArea.getBoundingClientRect();
    
    const x = 150 + Math.random() * 50;
    const y = Math.random() * (rect.height - 180);
    
    boardCard.style.left = `${x}px`;
    boardCard.style.top = `${y}px`;
    
    if (!multiplayer.gameId || player === multiplayer.playerNumber) {
        boardCard.addEventListener('mousedown', startDrag);
        boardCard.addEventListener('click', (e) => {
            e.stopPropagation();
            showCardZoom(cardData.image, { 
                type: 'board', 
                player: player, 
                cardId: cardId 
            });
        });
        boardCard.style.cursor = 'move';
        
        const controls = document.createElement('div');
        controls.className = 'card-controls';
        controls.innerHTML = `
            <button class="card-control-btn rotate-btn" onclick="rotateCardDirect(this.parentElement.parentElement)">‚Üª</button>
            <button class="card-control-btn delete-btn" onclick="showDeleteConfirmationForCard('${cardId}')">üóë</button>
        `;
        boardCard.appendChild(controls);
    } else {
        boardCard.style.cursor = 'default';
        boardCard.title = "Opponent's card";
        boardCard.addEventListener('click', (e) => {
            e.stopPropagation();
            showCardZoom(cardData.image, { 
                type: 'board', 
                player: player, 
                cardId: cardId,
                isOpponent: true 
            });
        });
    }
    
    playerArea.appendChild(boardCard);
    
    boardCards.push({
        id: cardId,
        image: cardData.image,
        player: player,
        element: boardCard,
        color: cardData.color,
        rotated: false
    });
    
    if (multiplayer.gameId) {
        setTimeout(() => {
            syncGameStateToFirebase();
        }, 100);
    }
}

function showCardZoom(image, source) {
    currentZoomImage = image;
    currentZoomSource = source;

    const zoomCard = document.getElementById("zoomCard");
    loadImageWithFallback(zoomCard, image, "#555");
    
    const isShop = (source.type === 'shop');
    const isHand = (source.type === 'hand');
    const isBoard = (source.type === 'board');
    const isGraveyard = (source.type === 'graveyard');
    const isDeck = (source.type === 'deck');
    const isLifeZone = (source.type === 'lifezone');
    const isOpponent = source.isOpponent;
    const isOurCard = multiplayer.gameId ? (source.player === multiplayer.playerNumber) : true;
    
    document.getElementById("addToDeckP1").style.display = isShop ? "inline-block" : "none";
    document.getElementById("addToDeckP2").style.display = isShop ? "inline-block" : "none";
    document.getElementById("playToBoard").style.display = (isHand && !isOpponent && isOurCard) ? "inline-block" : "none";
    document.getElementById("moveToHand").style.display = (isBoard && !isOpponent && isOurCard) ? "inline-block" : "none";
    document.getElementById("moveToDeck").style.display = (isBoard && !isOpponent && isOurCard) ? "inline-block" : "none";
    document.getElementById("moveToGY").style.display = ((isHand || isBoard) && !isOpponent && isOurCard) ? "inline-block" : "none";
    document.getElementById("putToBoardFromGY").style.display = (isGraveyard && !isOpponent && isOurCard) ? "inline-block" : "none";
    document.getElementById("putToBoardFromDeck").style.display = (isDeck && !isOpponent && isOurCard) ? "inline-block" : "none";
    
    document.getElementById("rotateCardBtn").style.display = (isBoard && !isOpponent && isOurCard) ? "inline-block" : "none";
    document.getElementById("removeFromLifeZone").style.display = (isLifeZone && !isOpponent && isOurCard) ? "inline-block" : "none";
    document.getElementById("flipLifeZoneCard").style.display = (isLifeZone && !isOpponent && isOurCard) ? "inline-block" : "none";
    document.getElementById("deleteCardBtn").style.display = (isBoard && !isOpponent && isOurCard) ? "inline-block" : "none";
    
    document.getElementById("zoomOverlay").style.display = "flex";
}

function closeZoomOnly() { 
    document.getElementById("zoomOverlay").style.display = "none"; 
    currentZoomSource = null;
    cardToDelete = null;
}

function playToBoard() {
    if (!currentZoomSource || currentZoomSource.type !== 'hand') return;
    
    const player = currentZoomSource.player;
    const cardId = currentZoomSource.cardId;
    
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only play cards from your own hand", 'error');
        return;
    }
    
    const cardIndex = hands[player].findIndex(card => card.id === cardId);
    if (cardIndex > -1) {
        const cardData = hands[player][cardIndex];
        hands[player].splice(cardIndex, 1);
        createBoardCard(cardData, player);
        updateCounters();
        closeZoomOnly();
        showNotification("Card Played", `Card played to board`, 'success');
        
        if (multiplayer.gameId) {
            setTimeout(() => {
                syncGameStateToFirebase();
            }, 100);
        }
    }
}

function moveToHand() {
    if (!currentZoomSource || currentZoomSource.type !== 'board') return;
    
    const player = currentZoomSource.player;
    const cardId = currentZoomSource.cardId;
    
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only move your own cards", 'error');
        return;
    }
    
    const cardIndex = boardCards.findIndex(card => card.id === cardId);
    if (cardIndex > -1) {
        const cardData = boardCards[cardIndex];
        boardCards.splice(cardIndex, 1);
        document.getElementById(cardId)?.remove();
        hands[player].push(cardData);
        updateCounters();
        closeZoomOnly();
        showNotification("Card Returned", `Card returned to hand`, 'info');
        
        if (multiplayer.gameId) {
            setTimeout(() => {
                syncGameStateToFirebase();
            }, 100);
        }
    }
}

function moveToGY() {
    if (!currentZoomSource) return;
    
    const player = currentZoomSource.player;
    const cardId = currentZoomSource.cardId;
    const sourceType = currentZoomSource.type;
    
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only move your own cards", 'error');
        return;
    }
    
    let cardData = null;
    
    if (sourceType === 'hand') {
        const cardIndex = hands[player].findIndex(card => card.id === cardId);
        if (cardIndex > -1) {
            cardData = hands[player][cardIndex];
            hands[player].splice(cardIndex, 1);
        }
    } else if (sourceType === 'board') {
        const cardIndex = boardCards.findIndex(card => card.id === cardId);
        if (cardIndex > -1) {
            cardData = boardCards[cardIndex];
            boardCards.splice(cardIndex, 1);
            document.getElementById(cardId)?.remove();
        }
    }
    
    if (cardData) {
        graveyards[player].push(cardData);
        updateCounters();
        closeZoomOnly();
        showNotification("Card Sent", `Card sent to graveyard`, 'info');
        
        if (multiplayer.gameId) {
            setTimeout(() => {
                syncGameStateToFirebase();
            }, 100);
        }
    }
}

function addToDeck(player) {
    if (currentZoomImage) {
        const cardId = `card_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        let categoryColor = "#555";
        for (const [categoryId, category] of Object.entries(CARD_CATEGORIES)) {
            if (quantitySelectorState.category === categoryId) {
                categoryColor = category.color;
                break;
            }
        }
        
        decks[player].push({ 
            image: currentZoomImage, 
            id: cardId,
            color: categoryColor
        });
        updateCounters();
        updateDeckVisual(player);
        closeZoomOnly();
        showNotification("Card Added", `Card added to deck`, 'success');
        
        if (multiplayer.gameId) {
            setTimeout(() => {
                syncGameStateToFirebase();
            }, 100);
        }
    }
}

function updateCounters() {
    document.getElementById("handCount1").textContent = hands[1].length;
    document.getElementById("handCount2").textContent = hands[2].length;
    document.getElementById("gyCount1").textContent = graveyards[1].length;
    document.getElementById("gyCount2").textContent = graveyards[2].length;
    updateDeckVisual(1);
    updateDeckVisual(2);
}

// ============================================================================
// MULTIPLAYER FUNCTIONS (REMAIN THE SAME)
// ============================================================================
function showMultiplayerMenu() {
    document.getElementById('multiplayerOverlay').style.display = 'flex';
}

function closeMultiplayerMenu() {
    document.getElementById('multiplayerOverlay').style.display = 'none';
}

function createGame() {
    if (!database) {
        showNotification("Firebase Error", "Database not initialized", "error");
        return;
    }
    
    multiplayer.playerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    multiplayer.playerNumber = 1;
    multiplayer.isHost = true;
    
    multiplayer.gameId = generateGameCode();
    
    document.getElementById('createGameSection').style.display = 'none';
    document.getElementById('joinGameSection').style.display = 'none';
    document.getElementById('gameInfoSection').style.display = 'block';
    document.getElementById('displayGameCode').textContent = multiplayer.gameId;
    
    multiplayer.gameRef = database.ref('games/' + multiplayer.gameId);
    multiplayer.boardStateRef = database.ref('boardStates/' + multiplayer.gameId);
    
    const initialGameState = getGameStateForSync();
    
    multiplayer.gameRef.set({
        hostId: multiplayer.playerId,
        players: {
            [multiplayer.playerId]: {
                playerNumber: 1,
                name: "Player 1",
                connected: true,
                lastSeen: Date.now()
            }
        },
        chat: [],
        createdAt: Date.now(),
        status: 'waiting'
    }).then(() => {
        multiplayer.boardStateRef.set(initialGameState);
        
        multiplayer.gameRef.on('value', handleGameUpdate);
        multiplayer.boardStateRef.on('value', handleBoardStateUpdate);
        
        showNotification('Game Created!', `Share code: ${multiplayer.gameId}`, 'success');
        
        const multiplayerBtn = document.getElementById('multiplayerButton');
        multiplayerBtn.textContent = 'üåê Room: ' + multiplayer.gameId;
        multiplayerBtn.style.background = 'linear-gradient(145deg, #4CAF50, #388E3C)';
    });
}

function joinGame() {
    const code = document.getElementById('gameCodeInput').value.trim().toUpperCase();
    if (!code || code.length !== 6) {
        showNotification('Invalid Code', 'Please enter a 6-digit code', 'error');
        return;
    }
    
    if (!database) {
        showNotification("Firebase Error", "Database not initialized", "error");
        return;
    }
    
    multiplayer.playerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    multiplayer.playerNumber = 2;
    multiplayer.isHost = false;
    multiplayer.gameId = code;
    
    multiplayer.gameRef = database.ref('games/' + code);
    multiplayer.boardStateRef = database.ref('boardStates/' + code);
    
    multiplayer.gameRef.once('value').then((snapshot) => {
        if (!snapshot.exists()) {
            showNotification('Game Not Found', 'Check the code and try again', 'error');
            return;
        }
        
        const gameData = snapshot.val();
        const players = gameData.players || {};
        const playerCount = Object.keys(players).length;
        
        if (playerCount >= 2) {
            showNotification('Game Full', 'This game already has 2 players', 'error');
            return;
        }
        
        return multiplayer.gameRef.update({
            [`players/${multiplayer.playerId}`]: {
                playerNumber: 2,
                name: "Player 2",
                connected: true,
                lastSeen: Date.now()
            },
            lastUpdate: Date.now(),
            status: 'playing'
        });
    }).then(() => {
        document.getElementById('createGameSection').style.display = 'none';
        document.getElementById('joinGameSection').style.display = 'none';
        document.getElementById('gameInfoSection').style.display = 'block';
        document.getElementById('displayGameCode').textContent = code;
        
        multiplayer.gameRef.on('value', handleGameUpdate);
        multiplayer.boardStateRef.on('value', handleBoardStateUpdate);
        
        showNotification('Joined Game!', 'Connected to host', 'success');
        
        const multiplayerBtn = document.getElementById('multiplayerButton');
        multiplayerBtn.textContent = 'üåê Room: ' + multiplayer.gameId;
        multiplayerBtn.style.background = 'linear-gradient(145deg, #2196F3, #1976D2)';
        
        multiplayer.boardStateRef.once('value').then((snapshot) => {
            if (snapshot.exists()) {
                syncGameStateFromFirebase(snapshot.val());
            }
        });
    });
}

function handleGameUpdate(snapshot) {
    if (!snapshot.exists()) {
        if (multiplayer.gameId) {
            showNotification('Game Ended', 'Host left the game', 'warning');
            leaveGame();
        }
        return;
    }
    
    const gameData = snapshot.val();
    
    const playerList = document.getElementById('playerList');
    if (playerList) {
        playerList.innerHTML = '';
        Object.entries(gameData.players || {}).forEach(([playerId, player]) => {
            const badgeClass = player.playerNumber === 1 ? 'player1-badge' : 'player2-badge';
            const youText = player.playerNumber === multiplayer.playerNumber ? ' (You)' : '';
            playerList.innerHTML += `<div class="player-badge ${badgeClass}">Player ${player.playerNumber}${youText} ‚úÖ</div>`;
        });
    }
    
    if (gameData.chat) {
        const chatContainer = document.getElementById('chatMessages');
        if (chatContainer) {
            chatContainer.innerHTML = '';
            Object.values(gameData.chat).forEach(msg => {
                const msgDiv = document.createElement('div');
                msgDiv.innerHTML = `<strong>Player ${msg.sender}:</strong> ${msg.text}`;
                msgDiv.style.margin = '5px 0';
                msgDiv.style.padding = '8px';
                msgDiv.style.background = msg.sender === multiplayer.playerNumber ? 'rgba(33, 150, 243, 0.2)' : 'rgba(255, 255, 255, 0.1)';
                msgDiv.style.borderRadius = '10px';
                chatContainer.appendChild(msgDiv);
            });
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
    }
}

function handleBoardStateUpdate(snapshot) {
    if (!snapshot.exists() || !multiplayer.gameId || multiplayer.isSyncing) return;
    
    const boardState = snapshot.val();
    
    if (boardState.lastUpdatePlayer === multiplayer.playerNumber) {
        return;
    }
    
    syncGameStateFromFirebase(boardState);
}

function sendChatMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    
    if (!message || !multiplayer.gameRef) return;
    
    const chatMessage = {
        sender: multiplayer.playerNumber,
        text: message,
        timestamp: Date.now()
    };
    
    multiplayer.gameRef.child('chat').push(chatMessage);
    input.value = '';
}

function copyGameCode() {
    if (!multiplayer.gameId) return;
    navigator.clipboard.writeText(multiplayer.gameId);
    showNotification('Copied!', 'Game code copied', 'success');
}

function copyGameLink() {
    if (!multiplayer.gameId) return;
    const link = window.location.href.split('?')[0] + '?game=' + multiplayer.gameId;
    navigator.clipboard.writeText(link);
    showNotification('Copied!', 'Invite link copied', 'success');
}

function leaveGame() {
    if (multiplayer.gameRef) {
        multiplayer.gameRef.child('players/' + multiplayer.playerId).remove();
        multiplayer.gameRef.off();
        multiplayer.boardStateRef.off();
    }
    
    multiplayer = {
        gameId: null,
        playerId: null,
        playerNumber: null,
        isHost: false,
        gameRef: null,
        boardStateRef: null,
        lastSyncTime: 0,
        isSyncing: false
    };
    
    document.getElementById('createGameSection').style.display = 'block';
    document.getElementById('joinGameSection').style.display = 'block';
    document.getElementById('gameInfoSection').style.display = 'none';
    
    const multiplayerBtn = document.getElementById('multiplayerButton');
    multiplayerBtn.textContent = 'üåê Online Play';
    multiplayerBtn.style.background = 'linear-gradient(145deg, #2196F3, #1976D2)';
    
    showNotification('Left Game', 'You have left the game', 'info');
}

function generateGameCode() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let result = '';
    for (let i = 0; i < 6; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
}

// ============================================================================
// SYNC FUNCTIONS (REMAIN THE SAME)
// ============================================================================
function getGameStateForSync() {
    const boardCardsData = boardCards.map(card => ({
        id: card.id,
        image: card.image,
        player: card.player,
        x: parseFloat(card.element?.style.left) || 0,
        y: parseFloat(card.element?.style.top) || 0,
        rotated: card.rotated || false,
        color: card.color
    }));
    
    const tokensData = {};
    Object.keys(counterTokens).forEach(player => {
        tokensData[player] = counterTokens[player].map(token => ({
            id: token.id,
            value: token.value || 0,
            label: token.label || 'Token',
            color: token.color,
            x: token.position?.x || 0,
            y: token.position?.y || 0,
            player: token.player
        }));
    });
    
    return {
        decks: JSON.parse(JSON.stringify(decks)),
        hands: JSON.parse(JSON.stringify(hands)),
        graveyards: JSON.parse(JSON.stringify(graveyards)),
        boardCards: boardCardsData,
        counterTokens: tokensData,
        lifeZones: JSON.parse(JSON.stringify(lifeZones)),
        timestamp: Date.now(),
        lastUpdatePlayer: multiplayer.playerNumber
    };
}

function syncGameStateToFirebase() {
    if (!multiplayer.boardStateRef || multiplayer.isSyncing) return;
    
    multiplayer.isSyncing = true;
    
    try {
        const gameState = getGameStateForSync();
        multiplayer.boardStateRef.set(gameState)
            .then(() => {
                console.log("‚úÖ Game state synced to Firebase");
            })
            .catch(error => {
                console.error("‚ùå Sync error:", error);
            })
            .finally(() => {
                multiplayer.isSyncing = false;
            });
    } catch (error) {
        console.error("‚ùå Error getting game state:", error);
        multiplayer.isSyncing = false;
    }
}

function syncGameStateFromFirebase(firebaseState) {
    if (multiplayer.isSyncing) return;
    
    multiplayer.isSyncing = true;
    
    try {
        const ourPlayer = multiplayer.playerNumber;
        
        document.querySelectorAll('.board-card').forEach(el => {
            const cardId = el.id;
            const card = boardCards.find(c => c.id === cardId);
            if (card && card.player !== ourPlayer) {
                el.remove();
            }
        });
        
        document.querySelectorAll('.counter-token').forEach(el => {
            const tokenId = el.id;
            for (const player of [1, 2]) {
                const token = counterTokens[player].find(t => t.id === tokenId);
                if (token && token.player !== ourPlayer) {
                    el.remove();
                    break;
                }
            }
        });
        
        boardCards = boardCards.filter(card => card.player === ourPlayer);
        counterTokens[1] = counterTokens[1].filter(token => token.player === ourPlayer);
        counterTokens[2] = counterTokens[2].filter(token => token.player === ourPlayer);
        
        if (firebaseState.decks) {
            decks = JSON.parse(JSON.stringify(firebaseState.decks));
        }
        
        if (firebaseState.hands) {
            hands = JSON.parse(JSON.stringify(firebaseState.hands));
        }
        
        if (firebaseState.graveyards) {
            graveyards = JSON.parse(JSON.stringify(firebaseState.graveyards));
        }
        
        if (firebaseState.boardCards) {
            firebaseState.boardCards.forEach(cardData => {
                const cardId = cardData.id;
                const player = cardData.player;
                
                if (document.getElementById(cardId)) return;
                
                const playerArea = document.getElementById(`player${player}Area`);
                if (!playerArea) return;
                
                const cardElement = document.createElement("div");
                cardElement.className = "board-card";
                cardElement.id = cardId;
                
                loadImageWithFallback(cardElement, cardData.image, cardData.color || "#555");
                
                cardElement.style.left = `${cardData.x}px`;
                cardElement.style.top = `${cardData.y}px`;
                
                if (cardData.color) {
                    cardElement.style.borderColor = cardData.color;
                    cardElement.style.borderWidth = "3px";
                }
                
                if (cardData.rotated) {
                    cardElement.classList.add('rotated');
                }
                
                if (player === ourPlayer) {
                    cardElement.addEventListener('mousedown', startDrag);
                    cardElement.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showCardZoom(cardData.image, { 
                            type: 'board', 
                            player: player, 
                            cardId: cardId 
                        });
                    });
                    cardElement.style.cursor = 'move';
                    
                    const controls = document.createElement('div');
                    controls.className = 'card-controls';
                    controls.innerHTML = `
                        <button class="card-control-btn rotate-btn" onclick="rotateCardDirect(this.parentElement.parentElement)">‚Üª</button>
                        <button class="card-control-btn delete-btn" onclick="showDeleteConfirmationForCard('${cardId}')">üóë</button>
                    `;
                    cardElement.appendChild(controls);
                } else {
                    cardElement.style.cursor = 'default';
                    cardElement.title = "Opponent's card";
                    cardElement.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showCardZoom(cardData.image, { 
                            type: 'board', 
                            player: player, 
                            cardId: cardId,
                            isOpponent: true 
                        });
                    });
                }
                
                playerArea.appendChild(cardElement);
                
                boardCards.push({
                    id: cardId,
                    image: cardData.image,
                    player: player,
                    element: cardElement,
                    color: cardData.color,
                    rotated: cardData.rotated || false
                });
            });
        }
        
        if (firebaseState.counterTokens) {
            Object.keys(firebaseState.counterTokens).forEach(player => {
                const playerNum = parseInt(player);
                
                firebaseState.counterTokens[player].forEach(tokenData => {
                    const tokenId = tokenData.id;
                    
                    if (document.getElementById(tokenId)) return;
                    
                    const playerArea = document.getElementById(`player${playerNum}Area`);
                    if (!playerArea) return;
                    
                    const tokenIndex = counterTokens[playerNum]?.length || 0;
                    const tokenColor = TOKEN_COLORS[playerNum][tokenIndex % 4] || '#444';
                    
                    const token = document.createElement("div");
                    token.className = `counter-token token-p${playerNum}-${(tokenIndex % 4) + 1}`;
                    token.id = tokenId;
                    token.style.left = `${tokenData.x || 0}px`;
                    token.style.top = `${tokenData.y || 0}px`;
                    
                    const isOurToken = playerNum === ourPlayer;
                    
                    if (isOurToken) {
                        token.innerHTML = `
                            <div class="counter-value">${tokenData.value || 0}</div>
                            <div class="counter-label">${tokenData.label || 'Token'}</div>
                            <div class="counter-controls">
                                <button class="counter-btn minus" onclick="changeTokenValue('${tokenId}', -1)">-</button>
                                <button class="counter-btn plus" onclick="changeTokenValue('${tokenId}', 1)">+</button>
                            </div>
                        `;
                        token.addEventListener('mousedown', startTokenDrag);
                        token.style.cursor = 'move';
                    } else {
                        token.innerHTML = `
                            <div class="counter-value">${tokenData.value || 0}</div>
                            <div class="counter-label">${tokenData.label || 'Token'}</div>
                        `;
                        token.style.cursor = 'default';
                        token.title = "Opponent's token";
                    }
                    
                    playerArea.appendChild(token);
                    
                    if (!counterTokens[playerNum]) {
                        counterTokens[playerNum] = [];
                    }
                    
                    counterTokens[playerNum].push({
                        id: tokenId,
                        player: playerNum,
                        value: tokenData.value || 0,
                        label: tokenData.label || 'Token',
                        color: tokenColor,
                        element: token,
                        position: { x: tokenData.x || 0, y: tokenData.y || 0 }
                    });
                });
            });
        }
        
        if (firebaseState.lifeZones) {
            lifeZones = JSON.parse(JSON.stringify(firebaseState.lifeZones));
            for (let player of [1, 2]) {
                for (let i = 0; i < 5; i++) {
                    const cardData = lifeZones[player][i];
                    updateLifeZoneDisplay(player, i, cardData, player !== ourPlayer);
                }
            }
        }
        
        updateCounters();
        updateDeckVisual(1);
        updateDeckVisual(2);
        
    } catch (error) {
        console.error("‚ùå Error loading game state:", error);
    } finally {
        multiplayer.isSyncing = false;
    }
}

// ============================================================================
// DRAG AND DROP (REMAIN THE SAME)
// ============================================================================
function startDrag(e) {
    const card = e.target.closest('.board-card');
    if (!card) return;
    
    const cardId = card.id;
    const cardData = boardCards.find(c => c.id === cardId);
    if (!cardData) return;
    
    if (multiplayer.gameId && cardData.player !== multiplayer.playerNumber) {
        return;
    }
    
    e.preventDefault();
    e.stopPropagation();
    
    dragState.mouseDownTime = Date.now();
    dragState.startX = e.clientX;
    dragState.startY = e.clientY;
    
    dragState.originalCard = card;
    dragState.originalParent = card.parentElement;
    dragState.originalLeft = parseFloat(card.style.left) || 0;
    dragState.originalTop = parseFloat(card.style.top) || 0;
    dragState.draggingToken = false;
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
}

function handleMouseMove(e) {
    if (!dragState.originalCard) return;
    
    const currentTime = Date.now();
    const timeDiff = currentTime - dragState.mouseDownTime;
    const distanceX = Math.abs(e.clientX - dragState.startX);
    const distanceY = Math.abs(e.clientY - dragState.startY);
    
    if (!dragState.isDragging && (timeDiff > 50 || distanceX > 5 || distanceY > 5)) {
        dragState.isDragging = true;
        
        dragState.card = dragState.originalCard.cloneNode(true);
        dragState.card.classList.add('dragging');
        dragState.card.style.left = `${e.clientX - 60}px`;
        dragState.card.style.top = `${e.clientY - 90}px`;
        document.body.appendChild(dragState.card);
        
        dragState.originalCard.style.visibility = "hidden";
    }
    
    if (dragState.isDragging && dragState.card) {
        dragState.card.style.left = `${e.clientX - 60}px`;
        dragState.card.style.top = `${e.clientY - 90}px`;
    }
}

function handleMouseUp(e) {
    if (dragState.isDragging && !dragState.draggingToken) {
        const playerArea = dragState.originalParent;
        const rect = playerArea.getBoundingClientRect();
        
        const relativeX = e.clientX - rect.left - 60;
        const relativeY = e.clientY - rect.top - 90;
        
        const boundedX = Math.max(0, Math.min(relativeX, rect.width - 120));
        const boundedY = Math.max(0, Math.min(relativeY, rect.height - 180));
        
        dragState.originalCard.style.left = `${boundedX}px`;
        dragState.originalCard.style.top = `${boundedY}px`;
        dragState.originalCard.style.visibility = "visible";
        
        if (dragState.card) {
            dragState.card.remove();
        }
        
        const cardId = dragState.originalCard.id;
        const cardIndex = boardCards.findIndex(c => c.id === cardId);
        if (cardIndex > -1) {
            boardCards[cardIndex].element = dragState.originalCard;
        }
        
        if (multiplayer.gameId) {
            setTimeout(() => {
                syncGameStateToFirebase();
            }, 100);
        }
    }
    
    dragState.isDragging = false;
    dragState.card = null;
    dragState.originalCard = null;
    dragState.draggingToken = false;
    
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
}

// ============================================================================
// TOKEN FUNCTIONS (REMAIN THE SAME)
// ============================================================================
function addTokenToPlayer(player) {
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only add tokens for yourself", 'error');
        return;
    }
    
    const playerArea = document.getElementById(`player${player}Area`);
    const tokenCount = counterTokens[player].length;
    
    if (tokenCount >= 4) {
        showNotification("Token Limit", "Maximum 4 tokens per player", 'warning');
        return;
    }
    
    const tokenId = `token_${player}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const tokenColor = TOKEN_COLORS[player][tokenCount];
    const tokenLabel = TOKEN_LABELS[tokenCount] || `Token ${tokenCount + 1}`;
    
    const token = document.createElement("div");
    token.className = `counter-token token-p${player}-${tokenCount + 1}`;
    token.id = tokenId;
    
    const rect = playerArea.getBoundingClientRect();
    const col = tokenCount % 2;
    const row = Math.floor(tokenCount / 2);
    const x = rect.width - 120 + (col * 60);
    const y = rect.height - 120 + (row * 60);
    
    token.style.left = `${x}px`;
    token.style.top = `${y}px`;
    
    token.innerHTML = `
        <div class="counter-value">0</div>
        <div class="counter-label">${tokenLabel}</div>
        <div class="counter-controls">
            <button class="counter-btn minus" onclick="changeTokenValue('${tokenId}', -1)">-</button>
            <button class="counter-btn plus" onclick="changeTokenValue('${tokenId}', 1)">+</button>
        </div>
    `;
    
    token.addEventListener('mousedown', startTokenDrag);
    token.style.cursor = 'move';
    
    playerArea.appendChild(token);
    
    counterTokens[player].push({
        id: tokenId,
        player: player,
        value: 0,
        label: tokenLabel,
        color: tokenColor,
        element: token,
        position: { x, y }
    });
    
    showNotification("Token Added", `${tokenLabel} token added`, 'success');
    
    if (multiplayer.gameId) {
        setTimeout(() => {
            syncGameStateToFirebase();
        }, 100);
    }
}

function changeTokenValue(tokenId, amount) {
    event.stopPropagation();
    
    for (const player of [1, 2]) {
        const tokenIndex = counterTokens[player].findIndex(token => token.id === tokenId);
        if (tokenIndex > -1) {
            if (multiplayer.gameId && player !== multiplayer.playerNumber) return;
            
            const token = counterTokens[player][tokenIndex];
            const newValue = token.value + amount;
            token.value = newValue;
            
            const valueElement = token.element.querySelector('.counter-value');
            if (valueElement) {
                valueElement.textContent = newValue;
            }
            
            if (multiplayer.gameId) {
                setTimeout(() => {
                    syncGameStateToFirebase();
                }, 100);
            }
            break;
        }
    }
}

function resetPlayerTokens(player) {
    if (multiplayer.gameId && player !== multiplayer.playerNumber) return;
    
    counterTokens[player].forEach(token => {
        if (token.element && token.element.parentElement) {
            token.element.remove();
        }
    });
    
    counterTokens[player] = [];
    showNotification("Tokens Reset", `Player ${player}'s tokens have been reset!`, 'info', 3000);
    
    if (multiplayer.gameId) {
        setTimeout(() => {
            syncGameStateToFirebase();
        }, 100);
    }
}

function startTokenDrag(e) {
    const token = e.target.closest('.counter-token');
    if (!token) return;
    
    const tokenId = token.id;
    let ourToken = false;
    for (const player of [1, 2]) {
        const tokenIndex = counterTokens[player].findIndex(t => t.id === tokenId);
        if (tokenIndex > -1 && player === multiplayer.playerNumber) {
            ourToken = true;
            break;
        }
    }
    
    if (!ourToken) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    dragState.mouseDownTime = Date.now();
    dragState.startX = e.clientX;
    dragState.startY = e.clientY;
    
    dragState.originalCard = token;
    dragState.originalParent = token.parentElement;
    dragState.originalLeft = parseFloat(token.style.left) || 0;
    dragState.originalTop = parseFloat(token.style.top) || 0;
    dragState.draggingToken = true;
    
    document.addEventListener('mousemove', handleTokenMouseMove);
    document.addEventListener('mouseup', handleTokenMouseUp);
}

function handleTokenMouseMove(e) {
    if (!dragState.originalCard || !dragState.draggingToken) return;
    
    const currentTime = Date.now();
    const timeDiff = currentTime - dragState.mouseDownTime;
    const distanceX = Math.abs(e.clientX - dragState.startX);
    const distanceY = Math.abs(e.clientY - dragState.startY);
    
    if (!dragState.isDragging && (timeDiff > 50 || distanceX > 5 || distanceY > 5)) {
        dragState.isDragging = true;
        
        dragState.card = dragState.originalCard.cloneNode(true);
        dragState.card.classList.add('dragging');
        dragState.card.style.width = "50px";
        dragState.card.style.height = "50px";
        dragState.card.style.left = `${e.clientX - 25}px`;
        dragState.card.style.top = `${e.clientY - 25}px`;
        document.body.appendChild(dragState.card);
        
        dragState.originalCard.style.visibility = "hidden";
    }
    
    if (dragState.isDragging && dragState.card) {
        dragState.card.style.left = `${e.clientX - 25}px`;
        dragState.card.style.top = `${e.clientY - 25}px`;
    }
}

function handleTokenMouseUp(e) {
    if (dragState.isDragging && dragState.draggingToken) {
        const playerArea = dragState.originalParent;
        const rect = playerArea.getBoundingClientRect();
        
        const relativeX = e.clientX - rect.left - 25;
        const relativeY = e.clientY - rect.top - 25;
        
        const boundedX = Math.max(0, Math.min(relativeX, rect.width - 50));
        const boundedY = Math.max(0, Math.min(relativeY, rect.height - 50));
        
        dragState.originalCard.style.left = `${boundedX}px`;
        dragState.originalCard.style.top = `${boundedY}px`;
        dragState.originalCard.style.visibility = "visible";
        
        if (dragState.card) {
            dragState.card.remove();
        }
        
        const tokenId = dragState.originalCard.id;
        for (const player of [1, 2]) {
            const tokenIndex = counterTokens[player].findIndex(token => token.id === tokenId);
            if (tokenIndex > -1) {
                counterTokens[player][tokenIndex].position = { x: boundedX, y: boundedY };
                break;
            }
        }
        
        if (multiplayer.gameId) {
            setTimeout(() => {
                syncGameStateToFirebase();
            }, 100);
        }
    }
    
    dragState.isDragging = false;
    dragState.card = null;
    dragState.originalCard = null;
    dragState.draggingToken = false;
    
    document.removeEventListener('mousemove', handleTokenMouseMove);
    document.removeEventListener('mouseup', handleTokenMouseUp);
}

// ============================================================================
// LIFE ZONE FUNCTIONS (REMAIN THE SAME)
// ============================================================================
function initializeLifeZones() {
    for (let player of [1, 2]) {
        const container = document.getElementById(`lifeZones${player}`);
        container.innerHTML = '';
        
        for (let i = 0; i < 5; i++) {
            const zone = document.createElement('div');
            zone.className = 'life-zone';
            zone.id = `lifeZone_${player}_${i}`;
            zone.setAttribute('data-player', player);
            zone.setAttribute('data-index', i);
            
            const number = document.createElement('div');
            number.className = 'life-zone-number';
            number.textContent = `L${i + 1}`;
            zone.appendChild(number);
            
            zone.addEventListener('dragover', handleLifeZoneDragOver);
            zone.addEventListener('drop', handleLifeZoneDrop);
            
            container.appendChild(zone);
        }
    }
}

function handleLifeZoneDragOver(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (dragState.isDragging && !dragState.draggingToken) {
        e.currentTarget.style.borderColor = '#9fea5f';
        e.currentTarget.style.boxShadow = '0 0 10px rgba(126, 211, 33, 0.5)';
    }
}

function handleLifeZoneDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (!dragState.isDragging || dragState.draggingToken) return;
    
    const zone = e.currentTarget;
    const player = parseInt(zone.getAttribute('data-player'));
    const index = parseInt(zone.getAttribute('data-index'));
    
    zone.style.borderColor = '';
    zone.style.boxShadow = '';
    
    if (dragState.originalCard && dragState.originalCard.classList.contains('board-card')) {
        const cardId = dragState.originalCard.id;
        const cardIndex = boardCards.findIndex(card => card.id === cardId);
        
        if (cardIndex > -1) {
            const cardData = boardCards[cardIndex];
            
            if (lifeZones[player][index]) {
                returnCardFromLifeZone(player, index);
            }
            
            boardCards.splice(cardIndex, 1);
            dragState.originalCard.remove();
            
            lifeZones[player][index] = {
                ...cardData,
                flipped: false
            };
            updateLifeZoneDisplay(player, index, lifeZones[player][index], player !== multiplayer.playerNumber);
            
            showNotification("Card Added to Life Zone", `Card added to Life Zone ${index + 1} for Player ${player}`, 'success', 3000);
            
            if (multiplayer.gameId) {
                setTimeout(() => {
                    syncGameStateToFirebase();
                }, 100);
            }
            return;
        }
    }
    
    if (currentZoomSource && currentZoomSource.type === 'hand') {
        const player = currentZoomSource.player;
        const cardId = currentZoomSource.cardId;
        const cardIndex = hands[player].findIndex(card => card.id === cardId);
        
        if (cardIndex > -1) {
            const cardData = hands[player][cardIndex];
            
            if (lifeZones[player][index]) {
                showNotification("Life Zone Full", `Life Zone ${index + 1} already has a card!`, 'warning', 3000);
                return;
            }
            
            hands[player].splice(cardIndex, 1);
            
            lifeZones[player][index] = {
                ...cardData,
                flipped: false
            };
            updateLifeZoneDisplay(player, index, lifeZones[player][index], player !== multiplayer.playerNumber);
            
            updateCounters();
            closeZoomOnly();
            
            showNotification("Card Added to Life Zone", `Card added to Life Zone ${index + 1} for Player ${player}`, 'success', 3000);
            
            if (multiplayer.gameId) {
                setTimeout(() => {
                    syncGameStateToFirebase();
                }, 100);
            }
            return;
        }
    }
}

function updateLifeZoneDisplay(player, index, cardData, isOpponent = false) {
    const zone = document.getElementById(`lifeZone_${player}_${index}`);
    if (!zone) return;
    
    zone.innerHTML = '';
    
    const number = document.createElement('div');
    number.className = 'life-zone-number';
    number.textContent = `L${index + 1}`;
    zone.appendChild(number);
    
    if (cardData) {
        zone.classList.add('has-card');
        
        const cardDisplay = document.createElement('div');
        cardDisplay.className = 'life-zone-card';
        
        if (cardData.flipped) {
            cardDisplay.classList.add('flipped');
        } else {
            loadImageWithFallback(cardDisplay, cardData.image, cardData.color || "#555");
        }
        
        if (isOpponent) {
            cardDisplay.title = "Opponent's card";
            cardDisplay.style.cursor = 'default';
        } else {
            cardDisplay.title = `Life Zone ${index + 1}: Click to view`;
            cardDisplay.style.cursor = 'pointer';
        }
        
        if (!isOpponent) {
            cardDisplay.onclick = (e) => {
                e.stopPropagation();
                if (cardData.flipped) {
                    showCardZoom(cardData.image, {
                        type: 'lifezone',
                        player: player,
                        zoneIndex: index,
                        cardId: cardData.id,
                        flipped: true
                    });
                } else {
                    showCardZoom(cardData.image, {
                        type: 'lifezone',
                        player: player,
                        zoneIndex: index,
                        cardId: cardData.id,
                        flipped: false
                    });
                }
            };
        }
        
        zone.appendChild(cardDisplay);
        
        if (!isOpponent) {
            const flipBtn = document.createElement('button');
            flipBtn.className = 'life-zone-flip-btn';
            flipBtn.innerHTML = '‚Üª';
            flipBtn.title = 'Flip card';
            flipBtn.onclick = (e) => {
                e.stopPropagation();
                flipLifeZoneCardDirect(player, index);
            };
            zone.appendChild(flipBtn);
        }
        
    } else {
        zone.classList.remove('has-card');
    }
}

function returnCardFromLifeZone(player, index) {
    const cardData = lifeZones[player][index];
    if (!cardData) return;
    
    const cardDataForBoard = { ...cardData, flipped: false, rotated: false };
    createBoardCard(cardDataForBoard, player);
    lifeZones[player][index] = null;
    updateLifeZoneDisplay(player, index, null, player !== multiplayer.playerNumber);
    
    showNotification("Card Returned to Board", `Card returned from Life Zone ${index + 1} to board`, 'info', 3000);
    
    if (multiplayer.gameId) {
        setTimeout(() => {
            syncGameStateToFirebase();
        }, 100);
    }
}

function shuffleLifeZones(player) {
    if (multiplayer.gameId && player !== multiplayer.playerNumber) return;
    
    const zones = lifeZones[player];
    const cards = zones.filter(card => card !== null);
    
    if (cards.length <= 1) {
        showNotification("Not Enough Cards", `Player ${player} needs at least 2 cards in life zones to shuffle!`, 'warning', 3000);
        return;
    }
    
    for (let i = cards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [cards[i], cards[j]] = [cards[j], cards[i]];
    }
    
    let cardIndex = 0;
    for (let i = 0; i < zones.length; i++) {
        if (zones[i] !== null) {
            lifeZones[player][i] = cards[cardIndex];
            updateLifeZoneDisplay(player, i, cards[cardIndex], player !== multiplayer.playerNumber);
            cardIndex++;
        }
    }
    
    showNotification("Life Zones Shuffled", `Player ${player}'s life zones have been shuffled!`, 'success', 3000);
    
    if (multiplayer.gameId) {
        setTimeout(() => {
            syncGameStateToFirebase();
        }, 100);
    }
}

function removeFromLifeZone() {
    if (!currentZoomSource || currentZoomSource.type !== 'lifezone') return;
    
    const player = currentZoomSource.player;
    const zoneIndex = currentZoomSource.zoneIndex;
    
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only remove cards from your own life zones", 'error');
        return;
    }
    
    const cardData = lifeZones[player][zoneIndex];
    if (cardData) {
        setTimeout(() => {
            const userChoice = confirm(`Remove card from Life Zone ${zoneIndex + 1}.\nOK = Put in hand\nCancel = Put on board`);
            
            if (userChoice) {
                hands[player].push({...cardData, flipped: false, rotated: false});
                showNotification("Card Moved to Hand", `Card moved from Life Zone ${zoneIndex + 1} to hand`, 'success', 2000);
            } else {
                createBoardCard({...cardData, flipped: false, rotated: false}, player);
                showNotification("Card Moved to Board", `Card moved from Life Zone ${zoneIndex + 1} to board`, 'success', 2000);
            }
            
            lifeZones[player][zoneIndex] = null;
            updateLifeZoneDisplay(player, zoneIndex, null, player !== multiplayer.playerNumber);
            updateCounters();
            closeZoomOnly();
            
            if (multiplayer.gameId) {
                setTimeout(() => {
                    syncGameStateToFirebase();
                }, 100);
            }
        }, 100);
    }
}

function flipLifeZoneCard() {
    if (!currentZoomSource || currentZoomSource.type !== 'lifezone') return;
    
    const player = currentZoomSource.player;
    const zoneIndex = currentZoomSource.zoneIndex;
    
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only flip cards in your own life zones", 'error');
        return;
    }
    
    const cardData = lifeZones[player][zoneIndex];
    if (cardData) {
        cardData.flipped = !cardData.flipped;
        updateLifeZoneDisplay(player, zoneIndex, cardData, player !== multiplayer.playerNumber);
        closeZoomOnly();
        
        const status = cardData.flipped ? "flipped face-down" : "flipped face-up";
        showNotification("Card Flipped", `Life Zone ${zoneIndex + 1} card ${status}`, 'info', 2000);
        
        if (multiplayer.gameId) {
            setTimeout(() => {
                syncGameStateToFirebase();
            }, 100);
        }
    }
}

function addToLifeZone(player) {
    if (!currentShopImage) {
        showNotification("No Card Selected", "Please select a card first!", 'warning', 3000);
        return;
    }
    
    const emptyIndex = lifeZones[player].findIndex(card => card === null);
    
    if (emptyIndex === -1) {
        showNotification("Life Zones Full", `Player ${player} has no empty life zones!`, 'warning', 3000);
        return;
    }
    
    const cardId = `life_${player}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    let categoryColor = "#7ED321";
    for (const [categoryId, category] of Object.entries(CARD_CATEGORIES)) {
        if (currentShopImage.includes(categoryId)) {
            categoryColor = category.color;
            break;
        }
    }
    
    const cardData = {
        image: currentShopImage,
        id: cardId,
        color: categoryColor,
        flipped: false
    };
    
    lifeZones[player][emptyIndex] = cardData;
    updateLifeZoneDisplay(player, emptyIndex, cardData, player !== multiplayer.playerNumber);
    
    showNotification("Card Added to Life Zone", `Card added to Life Zone ${emptyIndex + 1} for Player ${player}`, 'success', 3000);
    currentShopImage = null;
    
    if (multiplayer.gameId) {
        setTimeout(() => {
            syncGameStateToFirebase();
        }, 100);
    }
}

// ============================================================================
// VIEW FUNCTIONS (UPDATED WITH IMAGE LOADING)
// ============================================================================
function viewHand(player) {
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only view your own hand", 'warning');
        return;
    }
    
    const overlay = document.getElementById("handOverlay");
    const container = document.getElementById("handCardsContainer");
    document.getElementById("handTitle").textContent = `Player ${player}'s Hand (${hands[player].length} Cards)`;
    container.innerHTML = "";

    hands[player].forEach(cardData => {
        const card = document.createElement("div");
        card.className = "hand-display-card";
        
        loadImageWithFallback(card, cardData.image, cardData.color || "#555");
        
        if (cardData.color) {
            card.style.borderColor = cardData.color;
            card.style.borderWidth = "3px";
        }
        
        card.onclick = () => {
            showCardZoom(cardData.image, { 
                type: 'hand', 
                player: player, 
                cardId: cardData.id 
            });
        };
        container.appendChild(card);
    });

    overlay.style.display = "flex";
}

function closeHand() { 
    document.getElementById("handOverlay").style.display = "none"; 
}

function viewDeck(player) {
    const overlay = document.getElementById("deckOverlay");
    const container = document.getElementById("deckCardsContainer");
    document.getElementById("deckTitle").textContent = `Player ${player}'s Deck (${decks[player].length} Cards)`;
    container.innerHTML = "";

    decks[player].forEach((cardData, index) => {
        const card = document.createElement("div");
        card.className = "hand-display-card deck-card";
        
        loadImageWithFallback(card, cardData.image, cardData.color || "#555");
        
        if (cardData.color) {
            card.style.borderColor = cardData.color;
            card.style.borderWidth = "3px";
        }
        
        const positionBadge = document.createElement("div");
        positionBadge.style.position = "absolute";
        positionBadge.style.top = "5px";
        positionBadge.style.left = "5px";
        positionBadge.style.background = "rgba(0,0,0,0.7)";
        positionBadge.style.color = "white";
        positionBadge.style.padding = "2px 6px";
        positionBadge.style.borderRadius = "10px";
        positionBadge.style.fontSize = "10px";
        positionBadge.style.fontWeight = "bold";
        positionBadge.textContent = `#${index + 1}`;
        card.appendChild(positionBadge);
        
        card.onclick = () => {
            showCardZoom(cardData.image, { 
                type: 'deck', 
                player: player, 
                cardIndex: index 
            });
        };
        
        container.appendChild(card);
    });

    overlay.style.display = "flex";
}

function closeDeck() { 
    document.getElementById("deckOverlay").style.display = "none"; 
}

function viewGraveyard(player) {
    const overlay = document.getElementById("graveyardOverlay");
    const container = document.getElementById("graveyardCardsContainer");
    document.getElementById("graveyardTitle").textContent = `Player ${player}'s Graveyard (${graveyards[player].length} Cards)`;
    container.innerHTML = "";

    graveyards[player].forEach((cardData, index) => {
        const card = document.createElement("div");
        card.className = "hand-display-card gy-card";
        
        loadImageWithFallback(card, cardData.image, cardData.color || "#555");
        
        if (cardData.color) {
            card.style.borderColor = cardData.color;
            card.style.borderWidth = "3px";
        }
        
        card.onclick = () => {
            showCardZoom(cardData.image, { 
                type: 'graveyard', 
                player: player, 
                cardIndex: index 
            });
        };
        
        container.appendChild(card);
    });

    overlay.style.display = "flex";
}

function closeGraveyard() { 
    document.getElementById("graveyardOverlay").style.display = "none"; 
}

// ============================================================================
// OTHER FUNCTIONS (REMAIN THE SAME)
// ============================================================================
function rotateCard() {
    if (!currentZoomSource || currentZoomSource.type !== 'board') return;
    
    const cardId = currentZoomSource.cardId;
    const cardElement = document.getElementById(cardId);
    if (cardElement) {
        rotateCardDirect(cardElement);
        closeZoomOnly();
    }
}

function rotateCardDirect(cardElement) {
    if (!cardElement) return;
    
    cardElement.classList.toggle('rotated');
    
    const cardIndex = boardCards.findIndex(c => c.element === cardElement);
    if (cardIndex > -1) {
        boardCards[cardIndex].rotated = !boardCards[cardIndex].rotated;
    }
    
    if (multiplayer.gameId) {
        setTimeout(() => {
            syncGameStateToFirebase();
        }, 100);
    }
}

function showDeleteConfirmation() {
    if (!currentZoomSource || currentZoomSource.type !== 'board') return;
    
    const cardId = currentZoomSource.cardId;
    const cardElement = document.getElementById(cardId);
    
    if (cardElement) {
        cardToDelete = cardId;
        document.getElementById('confirmDeleteOverlay').style.display = 'flex';
    }
}

function showDeleteConfirmationForCard(cardId) {
    const cardElement = document.getElementById(cardId);
    if (cardElement) {
        cardToDelete = cardId;
        document.getElementById('confirmDeleteOverlay').style.display = 'flex';
    }
}

function confirmDeleteCard() {
    if (!cardToDelete) {
        cancelDeleteCard();
        return;
    }
    
    const cardIndex = boardCards.findIndex(card => card.id === cardToDelete);
    
    if (cardIndex > -1) {
        const cardElement = document.getElementById(cardToDelete);
        
        if (cardElement) {
            cardElement.classList.add('delete-animation');
            
            setTimeout(() => {
                cardElement.remove();
                boardCards.splice(cardIndex, 1);
                document.getElementById('confirmDeleteOverlay').style.display = 'none';
                closeZoomOnly();
                showNotification("Card Deleted", "Card has been permanently deleted!", 'info', 3000);
                
                if (multiplayer.gameId) {
                    setTimeout(() => {
                        syncGameStateToFirebase();
                    }, 100);
                }
            }, 500);
        }
    }
    
    cardToDelete = null;
}

function cancelDeleteCard() {
    cardToDelete = null;
    document.getElementById('confirmDeleteOverlay').style.display = 'none';
}

function flipLifeZoneCardDirect(player, index) {
    if (multiplayer.gameId && player !== multiplayer.playerNumber) return;
    
    const cardData = lifeZones[player][index];
    if (cardData) {
        cardData.flipped = !cardData.flipped;
        updateLifeZoneDisplay(player, index, cardData, player !== multiplayer.playerNumber);
        
        const status = cardData.flipped ? "flipped face-down" : "flipped face-up";
        showNotification("Card Flipped", `Life Zone ${index + 1} card ${status}`, 'info', 2000);
        
        if (multiplayer.gameId) {
            setTimeout(() => {
                syncGameStateToFirebase();
            }, 100);
        }
    }
}

// ============================================================================
// INITIALIZATION
// ============================================================================
window.addEventListener('load', function() {
    const urlParams = new URLSearchParams(window.location.search);
    const gameCode = urlParams.get('game');
    
    if (gameCode && gameCode.length === 6) {
        document.getElementById('gameCodeInput').value = gameCode;
        showMultiplayerMenu();
        
        setTimeout(() => {
            if (database) {
                joinGame();
            }
        }, 1000);
    }
    
    updateCounters();
    initializeLifeZones();
    setupShop();
    
    console.log(`
    ============================================
    üÉè CARD GAME READY!
    ============================================
    Loaded ${MANUAL_CARD_DATABASE.length} cards from database
    To add more cards from console:
    addCardToDatabase("https://res.cloudinary.com/...", "avatar", "Card Name")
    ============================================
    `);
});

// ============================================================================
// EVENT LISTENERS
// ============================================================================
document.getElementById("addToDeckP1").onclick = () => addToDeck(1);
document.getElementById("addToDeckP2").onclick = () => addToDeck(2);
document.getElementById("playToBoard").onclick = playToBoard;
document.getElementById("moveToHand").onclick = moveToHand;
document.getElementById("moveToGY").onclick = moveToGY;
document.getElementById('addToP1DeckQty').onclick = () => addMultipleToDeck(1);
document.getElementById('addToP2DeckQty').onclick = () => addMultipleToDeck(2);

// ============================================================================
// CONSOLE HELPER
// ============================================================================
window.cardUtils = {
    addCard: addCardToDatabase,
    listCards: () => console.log(MANUAL_CARD_DATABASE),
    countCards: () => console.log(`Total cards: ${MANUAL_CARD_DATABASE.length}`)
};

// ============================================================================
// ANIMATION STYLES
// ============================================================================
const style = document.createElement('style');
style.textContent = `
@keyframes shuffleSuccess {
    0% { box-shadow: 0 0 0 0 rgba(0, 170, 170, 0.7); }
    70% { box-shadow: 0 0 0 20px rgba(0, 170, 170, 0); }
    100% { box-shadow: 0 0 0 0 rgba(0, 170, 170, 0); }
}
`;
document.head.appendChild(style);
</script>
</body>
</html>
