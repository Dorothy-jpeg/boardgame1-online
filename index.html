<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Board Game - Real-Time Multiplayer</title>
    <!-- Add Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', sans-serif;
            background: #1b1b1b;
            color: white;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #board {
            position: relative;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .player-area {
            flex: 1;
            display: flex;
            position: relative;
            border-top: 2px solid #444;
            border-bottom: 2px solid #444;
            margin: 2px 0;
            overflow: hidden;
        }

        .card {
            width: 120px;
            height: 180px;
            border-radius: 6px;
            background-color: #555;
            border: 2px solid #000;
            background-size: cover;
            background-position: center;
            cursor: grab;
            flex-shrink: 0;
            transition: transform 0.1s, box-shadow 0.2s;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }
        .card.on-board { position: absolute; }
        .card.dragging { 
            opacity: 0.8; 
            cursor: grabbing; 
            pointer-events: none; 
            z-index: 9999 !important; 
            position: fixed !important; 
            transform: translate(-50%, -50%);
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        .controls { 
            position: absolute; 
            left: 160px;
            z-index: 100; 
            pointer-events: auto; 
            background: rgba(0,0,0,0.5); 
            padding: 5px; 
            border-radius: 4px; 
        }
        #p2Controls { top: 10px; }
        #p1Controls { bottom: 10px; }

        .token-controls {
            position: absolute;
            bottom: 5px;
            right: 5px;
            z-index: 100;
            pointer-events: auto;
            background: rgba(0,0,0,0.7);
            padding: 3px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 60px;
            border: 1px solid #666;
        }
        
        .token-controls-top {
            position: absolute;
            top: 5px;
            right: 5px;
            z-index: 100;
            pointer-events: auto;
            background: rgba(0,0,0,0.7);
            padding: 3px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 60px;
            border: 1px solid #666;
        }

        button { margin: 2px; padding: 6px 12px; cursor: pointer; background: #444; color: #fff; border: 1px solid #666; border-radius: 4px; }
        button:hover { background: #666; }
        #shopButton { position: absolute; top: 50%; right: 10px; transform: translateY(-50%); z-index: 200; background: #d4af37; color: #000; font-weight: bold; }

        .small-token-btn {
            background: #6a0dad;
            color: white;
            border: 1px solid #8a2be2;
            border-radius: 3px;
            padding: 2px 4px;
            font-size: 10px;
            cursor: pointer;
            margin: 1px;
            width: 100%;
            text-align: center;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .small-token-btn:hover {
            background: #8a2be2;
            transform: scale(1.05);
        }
        
        .small-token-reset-btn {
            background: #d35400;
            color: white;
            border: 1px solid #e67e22;
            border-radius: 3px;
            padding: 2px 4px;
            font-size: 10px;
            cursor: pointer;
            margin: 1px;
            width: 100%;
            text-align: center;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .small-token-reset-btn:hover {
            background: #e67e22;
            transform: scale(1.05);
        }
        
        .token-controls-label {
            font-size: 9px;
            text-align: center;
            color: #aaa;
            margin-bottom: 1px;
            font-weight: bold;
            border-bottom: 1px solid #444;
            padding-bottom: 2px;
        }

        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10050;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 300px;
            pointer-events: none;
        }
        
        .notification {
            background: rgba(0, 0, 0, 0.85);
            border-left: 4px solid #4A90E2;
            border-radius: 6px;
            padding: 12px 15px;
            color: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideInRight 0.3s ease-out;
            transform: translateX(0);
            opacity: 1;
            transition: all 0.3s ease;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        
        .notification.fade-out {
            opacity: 0;
            transform: translateX(100%);
        }
        
        .notification.success {
            border-left-color: #7ED321;
        }
        
        .notification.warning {
            border-left-color: #F5A623;
        }
        
        .notification.error {
            border-left-color: #D0021B;
        }
        
        .notification.info {
            border-left-color: #4A90E2;
        }
        
        .notification-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .notification-message {
            font-size: 13px;
            line-height: 1.4;
            color: #ddd;
        }
        
        .notification-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: #aaa;
            font-size: 16px;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }
        
        .notification-close:hover {
            background: rgba(255,255,255,0.1);
            color: white;
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .gy-shortcut-btn {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(40, 167, 69, 0.9);
            color: white;
            border: 1px solid #28a745;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 10px;
            cursor: pointer;
            z-index: 25;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            min-width: 40px;
            text-align: center;
        }
        
        .gy-shortcut-btn:hover {
            background: rgba(40, 167, 69, 1);
            transform: translateX(-50%) scale(1.1);
        }
        
        .board-card:hover .gy-shortcut-btn {
            opacity: 1;
        }
        
        .gy-shortcut-btn:active {
            transform: translateX(-50%) scale(0.95);
        }

        .hand-display-card, .shop-card { 
            width: 120px; 
            height: 180px; 
            border-radius: 6px; 
            background-size: cover; 
            background-position: center; 
            background-color: #555;
            border: 2px solid #333; 
            cursor: pointer; 
            transition: border-color 0.2s; 
            position: relative;
            overflow: hidden;
        }
        .hand-display-card:hover, .shop-card:hover { border-color: yellow; }

        .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: none; z-index: 10000; justify-content: center; align-items: center; flex-direction: column; }

        #shopWindow { width: 80%; height: 80%; background: #111; border: 2px solid #444; padding: 20px; border-radius: 8px; display: flex; flex-direction: column; }
        #shopCards { margin-top: 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 10px; overflow-y: auto; }
        .category-buttons { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .category-btn { background: #333; color: white; border: 1px solid #555; padding: 8px 16px; border-radius: 4px; cursor: pointer; }
        .category-btn:hover { background: #555; }
        .category-btn.active { background: #d4af37; color: #000; font-weight: bold; border-color: #ffd700; }

        #zoomOverlay { z-index: 10001; }
        #zoomCard { width: 360px; height: 540px; background-size: cover; background-position: center; border: 4px solid #fff; border-radius: 12px; margin-bottom: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.8); background-color: #555; }

        #handOverlay { z-index: 10000; }
        #handOverlayContent { background: #222; padding: 20px; border-radius: 8px; max-width: 90%; max-height: 90%; overflow: auto; }
        #handCardsContainer { display: grid; grid-template-columns: repeat(auto-fill, 120px); gap: 15px; margin-top: 20px; }

        .graveyard { 
            width: 140px; 
            height: 200px; 
            border: 2px dashed #888; 
            border-radius: 8px; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            flex-direction: column; 
            cursor: pointer; 
            text-align: center; 
            position: absolute; 
            right: 20px; 
            top: 50%; 
            transform: translateY(-50%); 
        }
        .graveyard:hover { border-color: yellow; }
        .graveyard-count { font-size: 16px; margin-top: 5px; }

        .deck-container {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 140px;
        }
        
        .deck-zone { 
            width: 140px; 
            height: 200px; 
            border: 2px dashed #666; 
            border-radius: 8px; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            flex-direction: column; 
            cursor: pointer; 
            text-align: center; 
            background: rgba(50, 50, 50, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .deck-visual {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .deck-card-stack {
            position: relative;
            width: 120px;
            height: 180px;
        }
        
        .deck-card-layer {
            position: absolute;
            width: 120px;
            height: 180px;
            border-radius: 6px;
            background: linear-gradient(145deg, #1a1a1a, #2c2c2c);
            border: 2px solid #444;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .deck-card-layer::before {
            content: '';
            position: absolute;
            width: 100px;
            height: 150px;
            background: linear-gradient(135deg, #333 0%, #555 50%, #333 100%);
            border-radius: 4px;
            border: 2px solid #666;
        }
        
        .deck-card-layer::after {
            content: 'DECK';
            position: absolute;
            color: #aaa;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
        
        .deck-card-layer:nth-child(1) { 
            transform: translate(0px, 0px); 
            background: linear-gradient(145deg, #1a1a1a, #2c2c2c);
        }
        .deck-card-layer:nth-child(2) { 
            transform: translate(2px, 2px); 
            background: linear-gradient(145deg, #222, #333);
        }
        .deck-card-layer:nth-child(3) { 
            transform: translate(4px, 4px); 
            background: linear-gradient(145deg, #2a2a2a, #3c3c3c);
        }
        .deck-card-layer:nth-child(4) { 
            transform: translate(6px, 6px); 
            background: linear-gradient(145deg, #333, #444);
        }
        .deck-card-layer:nth-child(5) { 
            transform: translate(8px, 8px); 
            background: linear-gradient(145deg, #3a3a3a, #4c4c4c);
        }
        
        .deck-zone.empty .deck-card-layer {
            display: none;
        }
        
        .deck-zone:hover { 
            border-color: cyan; 
            transform: translateY(-2px);
            transition: all 0.2s;
        }
        
        .deck-count { 
            font-size: 24px; 
            font-weight: bold;
            color: cyan;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 20px;
            min-width: 40px;
            text-align: center;
        }
        
        .deck-label {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
            color: cyan;
            text-align: center;
        }
        
        .deck-shuffle-btn {
            background: linear-gradient(145deg, #008080, #00aaaa);
            color: white;
            border: none;
            border-radius: 20px;
            padding: 6px 12px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            margin-top: 5px;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        
        .deck-shuffle-btn:hover {
            background: linear-gradient(145deg, #00aaaa, #00cccc);
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.4);
        }
        
        .deck-shuffle-btn:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .deck-shuffle-btn.shuffling {
            background: linear-gradient(145deg, #ff9900, #ffcc00);
            animation: shufflePulse 0.5s infinite alternate;
        }
        
        @keyframes shufflePulse {
            from { box-shadow: 0 0 5px rgba(255, 153, 0, 0.5); }
            to { box-shadow: 0 0 15px rgba(255, 153, 0, 0.8); }
        }
        
        .draw-animation {
            position: fixed;
            width: 120px;
            height: 180px;
            border-radius: 6px;
            background: linear-gradient(145deg, #1a1a1a, #2c2c2c);
            border: 2px solid #444;
            z-index: 99999;
            pointer-events: none;
            animation: drawCardMove 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .draw-animation::before {
            content: '';
            position: absolute;
            width: 100px;
            height: 150px;
            background: linear-gradient(135deg, #333 0%, #555 50%, #333 100%);
            border-radius: 4px;
            border: 2px solid #666;
        }
        
        .draw-animation::after {
            content: 'DRAW';
            position: absolute;
            color: #aaa;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
        
        @keyframes drawCardMove {
            0% {
                transform: scale(0.8) rotate(-10deg);
                opacity: 0;
            }
            20% {
                opacity: 1;
                transform: scale(1.1) rotate(5deg);
            }
            100% {
                transform: translate(var(--target-x), var(--target-y)) scale(1) rotate(0deg);
                opacity: 0;
            }
        }
        
        .open-btn {
            background: linear-gradient(145deg, #008080, #00aaaa);
            color: white;
            border: none;
            border-radius: 20px;
            padding: 8px 16px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            text-align: center;
            margin-top: 5px;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }
        
        .open-btn:hover {
            background: linear-gradient(145deg, #00aaaa, #00cccc);
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.4);
        }
        
        .open-btn:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .open-btn.opening {
            background: linear-gradient(145deg, #00cccc, #00eeee);
            animation: openPulse 0.3s infinite alternate;
        }
        
        @keyframes openPulse {
            from { box-shadow: 0 0 5px rgba(0, 204, 204, 0.5); }
            to { box-shadow: 0 0 15px rgba(0, 204, 204, 0.8); }
        }

        .board-card {
            position: absolute;
            width: 120px;
            height: 180px;
            border-radius: 6px;
            background-size: cover;
            background-position: center;
            cursor: move;
            border: 2px solid #000;
            z-index: 10;
            background-color: #555;
            user-select: none;
            transition: transform 0.3s ease;
        }
        
        .board-card.rotated {
            transform: rotate(-90deg);
            border-color: #ff9900;
        }
        
        .card-controls {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .board-card:hover .card-controls {
            opacity: 1;
        }
        
        .card-control-btn {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid #666;
            border-radius: 3px;
            padding: 3px 8px;
            font-size: 11px;
            cursor: pointer;
            min-width: 40px;
            text-align: center;
        }
        
        .card-control-btn:hover {
            background: rgba(50, 50, 50, 0.9);
        }
        
        .rotate-btn {
            background: rgba(255, 153, 0, 0.8);
        }
        
        .delete-btn {
            background: rgba(255, 68, 68, 0.8);
        }
        
        .delete-btn:hover {
            background: rgba(255, 100, 100, 0.9);
        }
        
        .delete-animation {
            animation: deleteCard 0.5s ease-out forwards;
            pointer-events: none;
        }
        
        @keyframes deleteCard {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(0.5);
                opacity: 0.5;
            }
            100% {
                transform: scale(0) rotate(180deg);
                opacity: 0;
            }
        }
        
        .confirm-delete-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 20000;
            justify-content: center;
            align-items: center;
        }
        
        .confirm-delete-box {
            background: #222;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
            border: 2px solid #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.3);
        }
        
        .confirm-delete-box h3 {
            color: #ff6b6b;
            margin-top: 0;
        }
        
        .confirm-delete-box p {
            margin: 20px 0;
            color: #ddd;
        }
        
        .confirm-delete-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }
        
        .confirm-delete-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            min-width: 100px;
        }
        
        .confirm-delete-btn:hover {
            background: #ff6666;
        }
        
        .cancel-delete-btn {
            background: #666;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            min-width: 100px;
        }
        
        .cancel-delete-btn:hover {
            background: #888;
        }
        
        .counter-token {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(145deg, #2c2c2c, #1a1a1a);
            border: 2px solid #444;
            cursor: move;
            z-index: 30;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            transition: transform 0.2s, box-shadow 0.2s;
            user-select: none;
        }
        
        .counter-token:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
            border-color: #666;
        }
        
        .counter-token.dragging {
            opacity: 0.8;
            cursor: grabbing;
            pointer-events: none;
            z-index: 9999 !important;
            position: fixed !important;
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.5);
        }
        
        .counter-value {
            font-size: 18px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .counter-label {
            font-size: 8px;
            color: #aaa;
            margin-top: 1px;
            text-align: center;
            max-width: 45px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .counter-controls {
            display: flex;
            gap: 3px;
            margin-top: 2px;
        }
        
        .counter-btn {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #444;
            border: none;
            color: white;
            font-size: 11px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            padding: 0;
        }
        
        .counter-btn:hover {
            background: #666;
        }
        
        .counter-btn.minus {
            background: #ff4444;
        }
        
        .counter-btn.plus {
            background: #44ff44;
        }
        
        .counter-btn.minus:hover {
            background: #ff6666;
        }
        
        .counter-btn.plus:hover {
            background: #66ff66;
        }
        
        .token-p1-1 { border-color: #ff6b6b; }
        .token-p1-1 .counter-value { color: #ff6b6b; }
        
        .token-p1-2 { border-color: #4ecdc4; }
        .token-p1-2 .counter-value { color: #4ecdc4; }
        
        .token-p1-3 { border-color: #ffe66d; }
        .token-p1-3 .counter-value { color: #ffe66d; }
        
        .token-p1-4 { border-color: #95e1d3; }
        .token-p1-4 .counter-value { color: #95e1d3; }
        
        .token-p2-1 { border-color: #ff9a76; }
        .token-p2-1 .counter-value { color: #ff9a76; }
        
        .token-p2-2 { border-color: #a8e6cf; }
        .token-p2-2 .counter-value { color: #a8e6cf; }
        
        .token-p2-3 { border-color: #ffd3b6; }
        .token-p2-3 .counter-value { color: #ffd3b6; }
        
        .token-p2-4 { border-color: #a8d8ea; }
        .token-p2-4 .counter-value { color: #a8d8ea; }
        
        .quantity-selector {
            background: #222;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            min-width: 300px;
        }
        
        .quantity-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }
        
        .qty-btn {
            width: 40px;
            height: 40px;
            font-size: 20px;
            background: #444;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            color: white;
        }
        
        .qty-btn:hover {
            background: #666;
        }
        
        .qty-display {
            font-size: 24px;
            font-weight: bold;
            min-width: 50px;
        }
        
        .quantity-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        #deckOverlayContent { 
            background: #222; 
            padding: 20px; 
            border-radius: 8px; 
            max-width: 90%; 
            max-height: 90%; 
            overflow: auto; 
        }
        #deckCardsContainer { 
            display: grid; 
            grid-template-columns: repeat(5, 1fr);
            grid-auto-rows: min-content;
            gap: 10px; 
            margin-top: 20px; 
        }
        
        .deck-card {
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .deck-card:hover {
            transform: scale(1.05);
        }
        
        .deck-card-row {
            display: contents;
        }
        
        .deck-card:nth-child(5n+1) { grid-column: 1; }
        .deck-card:nth-child(5n+2) { grid-column: 2; }
        .deck-card:nth-child(5n+3) { grid-column: 3; }
        .deck-card:nth-child(5n+4) { grid-column: 4; }
        .deck-card:nth-child(5n+5) { grid-column: 5; }
        
        .life-zones-container {
            position: absolute;
            top: 10px;
            right: 160px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }

        .life-zone {
            width: 100px;
            height: 40px;
            border: 2px dashed #7ED321;
            border-radius: 6px;
            background: rgba(126, 211, 33, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .life-zone:hover {
            border-color: #9fea5f;
            background: rgba(126, 211, 33, 0.2);
        }

        .life-zone.has-card {
            border-style: solid;
            border-color: #7ED321;
            background: rgba(126, 211, 33, 0.3);
        }

        .life-zone-card {
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            border-radius: 4px;
            position: relative;
        }
        
        .life-zone-card.flipped {
            transform: rotateY(180deg);
            background: linear-gradient(45deg, #333, #666);
        }
        
        .life-zone-card.flipped::after {
            content: "FACEDOWN";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotateY(180deg);
            color: white;
            font-weight: bold;
            font-size: 8px;
            text-align: center;
        }

        .life-zone-number {
            position: absolute;
            top: 2px;
            left: 2px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 10px;
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: bold;
        }

        .life-zone-label {
            font-size: 11px;
            color: #7ED321;
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
        }

        .life-shuffle-btn {
            background: #7ED321;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            margin-top: 5px;
            width: 100%;
        }

        .life-shuffle-btn:hover {
            background: #9fea5f;
        }
        
        .life-zone-flip-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            background: rgba(0, 204, 255, 0.9);
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .life-zone.has-card:hover .life-zone-flip-btn {
            opacity: 1;
        }
        
        .life-zone-flip-btn:hover {
            background: rgba(0, 204, 255, 1);
            transform: scale(1.1);
        }
        
        .add-to-life-btn {
            background: #7ED321;
            color: white;
            border: 1px solid #9fea5f;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-weight: bold;
            margin: 2px;
        }
        
        .add-to-life-btn:hover {
            background: #9fea5f;
        }
        
        .shuffle-animation {
            position: fixed;
            width: 120px;
            height: 180px;
            border-radius: 6px;
            background: linear-gradient(145deg, #2c2c2c, #1a1a1a);
            border: 2px solid #444;
            z-index: 99999;
            pointer-events: none;
            animation: shuffleCard 0.8s ease-out;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .shuffle-animation::before {
            content: '';
            position: absolute;
            width: 100px;
            height: 150px;
            background: linear-gradient(135deg, #333 0%, #555 50%, #333 100%);
            border-radius: 4px;
            border: 2px solid #666;
        }
        
        .shuffle-animation::after {
            content: 'SHUFFLE';
            position: absolute;
            color: #aaa;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
        
        @keyframes shuffleCard {
            0% {
                transform: translate(var(--start-x), var(--start-y)) scale(1) rotate(0deg);
                opacity: 1;
            }
            30% {
                transform: translate(calc(var(--start-x) + 50px), calc(var(--start-y) - 100px)) scale(1.1) rotate(180deg);
                opacity: 0.8;
            }
            60% {
                transform: translate(calc(var(--start-x) - 50px), calc(var(--start-y) + 100px)) scale(1.2) rotate(360deg);
                opacity: 0.6;
            }
            100% {
                transform: translate(var(--start-x), var(--start-y)) scale(1) rotate(720deg);
                opacity: 0;
            }
        }

        .multiplayer-btn {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            z-index: 200;
            background: linear-gradient(145deg, #2196F3, #1976D2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
            transition: all 0.3s;
        }
        
        .multiplayer-btn:hover {
            background: linear-gradient(145deg, #1976D2, #1565C0);
            transform: translateY(-50%) scale(1.05);
        }
        
        .multiplayer-overlay {
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
        }
        
        .multiplayer-panel {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            border: 2px solid #2196F3;
            box-shadow: 0 0 30px rgba(33, 150, 243, 0.2);
        }
        
        .game-code {
            font-family: monospace;
            font-size: 32px;
            letter-spacing: 3px;
            background: #333;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            color: #4CAF50;
            text-align: center;
            border: 2px solid #4CAF50;
        }
        
        .copy-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        
        .player-status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .player-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            margin: 5px;
            font-weight: bold;
        }
        
        .player1-badge {
            background: rgba(68, 136, 255, 0.2);
            border: 2px solid #4488ff;
            color: #4488ff;
        }
        
        .player2-badge {
            background: rgba(136, 68, 255, 0.2);
            border: 2px solid #8844ff;
            color: #8844ff;
        }
        
        .chat-box {
            margin-top: 20px;
            border-top: 1px solid #444;
            padding-top: 20px;
        }
        
        .chat-messages {
            height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
        }
        
        .chat-input {
            width: 100%;
            padding: 10px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 5px;
        }
    </style>
</head>
<body>

<!-- NOTIFICATION CONTAINER -->
<div class="notification-container" id="notificationContainer"></div>

<!-- MULTIPLAYER OVERLAY -->
<div id="multiplayerOverlay" class="overlay multiplayer-overlay" style="display: none;">
    <div class="multiplayer-panel">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h2 style="color: #2196F3; margin: 0;">üåê Online Multiplayer</h2>
            <button onclick="closeMultiplayerMenu()" style="background:#c00; padding: 8px 16px;">Close</button>
        </div>
        
        <div id="createGameSection">
            <h3>üéÆ Host New Game</h3>
            <p>Create a game room and invite your friend</p>
            <button onclick="createGame()" style="background: #4CAF50; padding: 15px 30px; font-size: 18px; margin: 15px 0; width: 100%;">
                üöÄ Create Game Room
            </button>
        </div>
        
        <div id="joinGameSection" style="margin-top: 30px;">
            <h3>üîó Join Game</h3>
            <p>Enter the game code from your friend:</p>
            <input type="text" id="gameCodeInput" placeholder="Enter 6-digit code" 
                   style="padding: 15px; width: 100%; font-size: 18px; margin: 10px 0; text-align: center; letter-spacing: 3px;"
                   maxlength="6" oninput="this.value = this.value.toUpperCase()">
            <button onclick="joinGame()" style="background: #2196F3; padding: 15px 30px; width: 100%; font-size: 16px;">
                ‚úÖ Join Game
            </button>
        </div>
        
        <div id="gameInfoSection" style="display: none;">
            <h3>üéÆ Game Room</h3>
            <p>Share this code with your friend:</p>
            <div class="game-code" id="displayGameCode">XXXXXX</div>
            
            <div style="display: flex; gap: 10px; justify-content: center; margin: 15px 0;">
                <button class="copy-btn" onclick="copyGameCode()">
                    üìã Copy Code
                </button>
                <button class="copy-btn" onclick="copyGameLink()" style="background: #2196F3;">
                    üîó Copy Invite Link
                </button>
            </div>
            
            <div class="player-status">
                <h4>üë• Players</h4>
                <div id="playerList">
                    <div class="player-badge player1-badge">Player 1 (You) ‚úÖ</div>
                    <div class="player-badge player2-badge">Player 2 (Waiting...)</div>
                </div>
            </div>
            
            <div class="chat-box">
                <h4>üí¨ Chat</h4>
                <div class="chat-messages" id="chatMessages">
                    <div style="color: #888; font-style: italic;">Chat messages will appear here...</div>
                </div>
                <div style="display: flex; gap: 10px;">
                    <input type="text" class="chat-input" id="chatInput" placeholder="Type message..." 
                           onkeypress="if(event.key === 'Enter') sendChatMessage()">
                    <button onclick="sendChatMessage()" style="background: #666; padding: 10px 20px;">Send</button>
                </div>
            </div>
            
            <button onclick="leaveGame()" style="background: #f44336; padding: 12px 24px; width: 100%; margin-top: 20px;">
                üö™ Leave Game
            </button>
        </div>
    </div>
</div>

<div id="board">
    <!-- MULTIPLAYER BUTTON -->
    <button class="multiplayer-btn" onclick="showMultiplayerMenu()" id="multiplayerButton">
        üåê Online Play
    </button>

    <!-- PLAYER 2 AREA -->
    <div class="player-area" id="player2Area">
        <!-- DECK CONTAINER -->
        <div class="deck-container">
            <div class="deck-label">Deck P2</div>
            <div id="deck2" class="deck-zone" onclick="viewDeck(2)">
                <div class="deck-visual">
                    <div class="deck-card-stack"></div>
                    <span class="deck-count" id="deckCount2">0</span>
                </div>
            </div>
            <button class="deck-shuffle-btn" id="shuffleBtn2" onclick="shuffleDeckWithAnimation(2)" disabled>üîÄ Shuffle Deck</button>
            <button class="open-btn" id="openBtn2" onclick="openFromDeck(2)" disabled>Open from Deck</button>
        </div>
        
        <!-- PLAYER 2 CONTROLS -->
        <div id="p2Controls" class="controls">
            <strong>P2</strong> | Hand: <span id="handCount2">0</span>
            <button onclick="drawCardWithAnimation(2)">Draw</button>
            <button onclick="viewHand(2)">View Hand</button>
        </div>
        
        <!-- PLAYER 2 TOKEN CONTROLS -->
        <div class="token-controls-top">
            <div class="token-controls-label">P2 Tokens</div>
            <button class="small-token-btn" onclick="addTokenToPlayer(2)">Token</button>
            <button class="small-token-reset-btn" onclick="resetPlayerTokens(2)">Reset</button>
        </div>
        
        <!-- LIFE ZONES -->
        <div class="life-zones-container">
            <div class="life-zone-label">Life Zones</div>
            <div id="lifeZones2" class="life-zones"></div>
            <button class="life-shuffle-btn" onclick="shuffleLifeZones(2)">üîÄ Shuffle Life Zones</button>
        </div>
        
        <!-- GRAVEYARD ZONE -->
        <div id="gy2" class="graveyard" onclick="viewGraveyard(2)">
            <span>Graveyard P2</span>
            <span class="graveyard-count" id="gyCount2">0</span>
        </div>
    </div>

    <!-- PLAYER 1 AREA -->
    <div class="player-area" id="player1Area">
        <!-- DECK CONTAINER -->
        <div class="deck-container">
            <div class="deck-label">Deck P1</div>
            <div id="deck1" class="deck-zone" onclick="viewDeck(1)">
                <div class="deck-visual">
                    <div class="deck-card-stack"></div>
                    <span class="deck-count" id="deckCount1">0</span>
                </div>
            </div>
            <button class="deck-shuffle-btn" id="shuffleBtn1" onclick="shuffleDeckWithAnimation(1)" disabled>üîÄ Shuffle Deck</button>
            <button class="open-btn" id="openBtn1" onclick="openFromDeck(1)" disabled>Open from Deck</button>
        </div>
        
        <!-- PLAYER 1 CONTROLS -->
        <div id="p1Controls" class="controls">
            <strong>P1</strong> | Hand: <span id="handCount1">0</span>
            <button onclick="drawCardWithAnimation(1)">Draw</button>
            <button onclick="viewHand(1)">View Hand</button>
        </div>
        
        <!-- PLAYER 1 TOKEN CONTROLS -->
        <div class="token-controls">
            <div class="token-controls-label">P1 Tokens</div>
            <button class="small-token-btn" onclick="addTokenToPlayer(1)">Token</button>
            <button class="small-token-reset-btn" onclick="resetPlayerTokens(1)">Reset</button>
        </div>
        
        <!-- LIFE ZONES -->
        <div class="life-zones-container">
            <div class="life-zone-label">Life Zones</div>
            <div id="lifeZones1" class="life-zones"></div>
            <button class="life-shuffle-btn" onclick="shuffleLifeZones(1)">üîÄ Shuffle Life Zones</button>
        </div>
        
        <!-- GRAVEYARD ZONE -->
        <div id="gy1" class="graveyard" onclick="viewGraveyard(1)">
            <span>Graveyard P1</span>
            <span class="graveyard-count" id="gyCount1">0</span>
        </div>
    </div>

    <button id="shopButton" onclick="openShop()">üõçÔ∏è Shop</button>
</div>

<!-- SHOP OVERLAY -->
<div id="shopOverlay" class="overlay" style="align-items: stretch;">
    <div id="shopWindow">
        <div style="display:flex; justify-content:space-between;">
            <h2>Card Shop</h2> 
            <button onclick="closeShop()" style="background:#c00">Close</button>
        </div>
        
        <!-- CATEGORY BUTTONS -->
        <div class="category-buttons">
            <button class="category-btn active" onclick="filterShopCards('all', event)">All Cards</button>
            <button class="category-btn" onclick="filterShopCards('avatar', event)">Avatar</button>
            <button class="category-btn" onclick="filterShopCards('magic', event)">Magic</button>
            <button class="category-btn" onclick="filterShopCards('construct', event)">Construct</button>
            <button class="category-btn" onclick="filterShopCards('life', event)">Life</button>
        </div>
        
        <!-- SPECIAL BUTTONS FOR LIFE CATEGORY -->
        <div id="lifeCategoryButtons" style="display: none; gap: 10px; margin-bottom: 15px;">
            <button class="add-to-life-btn" onclick="addToLifeZone(1)">Add to P1 Life Zone</button>
            <button class="add-to-life-btn" onclick="addToLifeZone(2)">Add to P2 Life Zone</button>
        </div>
        
        <div id="shopCards"></div>
    </div>
</div>

<!-- QUANTITY SELECTOR OVERLAY -->
<div id="quantityOverlay" class="overlay">
    <div class="quantity-selector">
        <h3>Add Cards to Deck</h3>
        <div id="quantityCardPreview" style="width: 120px; height: 180px; margin: 0 auto 20px; background-size: cover; border-radius: 6px;"></div>
        <p>How many copies do you want to add?</p>
        
        <div class="quantity-controls">
            <button class="qty-btn" onclick="changeQuantity(-1)">-</button>
            <div class="qty-display" id="quantityDisplay">1</div>
            <button class="qty-btn" onclick="changeQuantity(1)">+</button>
        </div>
        
        <div class="quantity-actions">
            <button id="addToP1DeckQty" style="background:#448;">Add to P1 Deck</button>
            <button id="addToP2DeckQty" style="background:#844;">Add to P2 Deck</button>
            <button onclick="closeQuantitySelector()" style="background:#c00">Cancel</button>
        </div>
    </div>
</div>

<!-- ZOOM OVERLAY -->
<div id="zoomOverlay" class="overlay">
    <div id="zoomCard"></div>
    <div style="display:flex; gap:10px; flex-wrap: wrap; justify-content: center;">
        <button id="addToDeckP1" style="background:#448;">Add to P1 Deck</button>
        <button id="addToDeckP2" style="background:#844;">Add to P2 Deck</button>
        <button id="playToBoard" style="background:#282;">Play</button>
        <button id="moveToHand" style="background:#448;">Put to Hand</button>
        <button id="moveToDeck" style="background:#844;">Put to Deck</button>
        <button id="moveToGY" style="background:#282;">Send to GY</button>
        <button id="putToBoardFromGY" style="background:#8B4513; display:none;">Put to Board</button>
        <button id="putToBoardFromDeck" style="background:#008080; display:none;">Put to Board</button>
        <button id="rotateCardBtn" style="background:#ff9900; display:none;" onclick="rotateCard()">Rotate</button>
        <button id="removeFromLifeZone" style="background:#d35400; display:none;" onclick="removeFromLifeZone()">Remove from Life Zone</button>
        <button id="flipLifeZoneCard" style="background:#00ccff; display:none;" onclick="flipLifeZoneCard()">Flip Card</button>
        <button id="deleteCardBtn" style="background:#ff4444; display:none;" onclick="showDeleteConfirmation()">Delete</button>
        <button onclick="closeZoomOnly()">Close</button>
    </div>
</div>

<!-- CONFIRM DELETE OVERLAY -->
<div id="confirmDeleteOverlay" class="confirm-delete-overlay">
    <div class="confirm-delete-box">
        <h3>‚ö†Ô∏è Delete Card</h3>
        <p>Are you sure you want to delete this card?</p>
        <p><strong>This action cannot be undone!</strong></p>
        <p>The card will be permanently removed from the board.</p>
        
        <div class="confirm-delete-actions">
            <button class="confirm-delete-btn" onclick="confirmDeleteCard()">Yes, Delete</button>
            <button class="cancel-delete-btn" onclick="cancelDeleteCard()">Cancel</button>
        </div>
    </div>
</div>

<!-- HAND OVERLAY -->
<div id="handOverlay" class="overlay">
    <div id="handOverlayContent">
        <h2 id="handTitle">Cards</h2>
        <div id="handCardsContainer"></div>
        <button onclick="closeHand()">Close</button>
    </div>
</div>

<!-- DECK OVERLAY -->
<div id="deckOverlay" class="overlay">
    <div id="deckOverlayContent">
        <h2 id="deckTitle">Deck</h2>
        <div id="deckCardsContainer"></div>
        <button onclick="closeDeck()">Close</button>
    </div>
</div>

<!-- GRAVEYARD OVERLAY -->
<div id="graveyardOverlay" class="overlay">
    <div id="graveyardOverlayContent" style="background: #222; padding: 20px; border-radius: 8px; max-width: 90%; max-height: 90%; overflow: auto;">
        <h2 id="graveyardTitle">Graveyard</h2>
        <div id="graveyardCardsContainer" style="display: grid; grid-template-columns: repeat(auto-fill, 120px); gap: 15px; margin-top: 20px;"></div>
        <button onclick="closeGraveyard()">Close</button>
    </div>
</div>

<script>
// ============================================================================
// FIREBASE CONFIGURATION
// ============================================================================
const firebaseConfig = {
  apiKey: "AIzaSyCWJUqRC00L1h7W8BgDmP8UjVHXbyaJaas",
  authDomain: "boardgame2-95da5.firebaseapp.com",
  databaseURL: "https://boardgame2-95da5-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "boardgame2-95da5",
  storageBucket: "boardgame2-95da5.firebasestorage.app",
  messagingSenderId: "196618431674",
  appId: "1:196618431674:web:fc4898cb08f60420b26683"
};

// Initialize Firebase
let database;
try {
  firebase.initializeApp(firebaseConfig);
  database = firebase.database();
  console.log("‚úÖ Firebase initialized successfully!");
} catch (error) {
  console.error("‚ùå Firebase error:", error);
}

// ============================================================================
// NOTIFICATION SYSTEM
// ============================================================================
function showNotification(title, message, type = 'info', duration = 3000) {
    const container = document.getElementById('notificationContainer');
    if (!container) return;
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    
    const icon = type === 'success' ? '‚úì' : 
                 type === 'warning' ? '‚ö†' : 
                 type === 'error' ? '‚úó' : 
                 '‚Ñπ';
    
    notification.innerHTML = `
        <button class="notification-close" onclick="this.parentElement.classList.add('fade-out')">√ó</button>
        <div class="notification-title">${icon} ${title}</div>
        <div class="notification-message">${message}</div>
    `;
    
    container.appendChild(notification);
    
    if (duration > 0) {
        setTimeout(() => {
            notification.classList.add('fade-out');
            setTimeout(() => notification.remove(), 300);
        }, duration);
    }
}

// ============================================================================
// MULTIPLAYER STATE - REAL-TIME SYNC
// ============================================================================
let multiplayer = {
    gameId: null,
    playerId: null,
    playerNumber: null,
    isHost: false,
    gameRef: null,
    boardStateRef: null,
    isSyncing: false
};

// ============================================================================
// FIXED SYNC FUNCTIONS
// ============================================================================
function getGameStateForSync() {
    const boardCardsData = boardCards.map(card => ({
        id: card.id,
        image: card.image,
        player: card.player,
        x: parseFloat(card.element?.style.left) || 0,
        y: parseFloat(card.element?.style.top) || 0,
        rotated: card.rotated || false,
        color: card.color
    }));
    
    const tokensData = {};
    Object.keys(counterTokens).forEach(player => {
        tokensData[player] = counterTokens[player].map(token => ({
            id: token.id,
            value: token.value || 0,
            label: token.label || 'Token',
            color: token.color,
            x: token.position?.x || 0,
            y: token.position?.y || 0,
            player: token.player
        }));
    });
    
    return {
        decks: JSON.parse(JSON.stringify(decks)),
        hands: JSON.parse(JSON.stringify(hands)),
        graveyards: JSON.parse(JSON.stringify(graveyards)),
        boardCards: boardCardsData,
        counterTokens: tokensData,
        lifeZones: JSON.parse(JSON.stringify(lifeZones)),
        timestamp: Date.now(),
        lastUpdatePlayer: multiplayer.playerNumber
    };
}

function syncGameStateToFirebase() {
    if (!multiplayer.boardStateRef || multiplayer.isSyncing) return;
    
    multiplayer.isSyncing = true;
    
    try {
        const gameState = getGameStateForSync();
        multiplayer.boardStateRef.set(gameState)
            .then(() => {
                console.log("‚úÖ Game state synced to Firebase");
            })
            .catch(error => {
                console.error("‚ùå Sync error:", error);
            })
            .finally(() => {
                multiplayer.isSyncing = false;
            });
    } catch (error) {
        console.error("‚ùå Error getting game state:", error);
        multiplayer.isSyncing = false;
    }
}

function syncGameStateFromFirebase(firebaseState) {
    if (multiplayer.isSyncing) return;
    
    multiplayer.isSyncing = true;
    
    try {
        const ourPlayer = multiplayer.playerNumber;
        
        // CLEAR ALL OPPONENT'S VISUAL ELEMENTS FIRST
        document.querySelectorAll('.board-card').forEach(el => {
            const cardId = el.id;
            const card = boardCards.find(c => c.id === cardId);
            if (card && card.player !== ourPlayer) {
                el.remove();
            }
        });
        
        document.querySelectorAll('.counter-token').forEach(el => {
            const tokenId = el.id;
            for (const player of [1, 2]) {
                const token = counterTokens[player].find(t => t.id === tokenId);
                if (token && token.player !== ourPlayer) {
                    el.remove();
                    break;
                }
            }
        });
        
        // CLEAR LOCAL STATE OF OPPONENT'S CARDS/TOKENS
        boardCards = boardCards.filter(card => card.player === ourPlayer);
        counterTokens[1] = counterTokens[1].filter(token => token.player === ourPlayer);
        counterTokens[2] = counterTokens[2].filter(token => token.player === ourPlayer);
        
        // UPDATE LOCAL STATE FROM FIREBASE
        if (firebaseState.decks) {
            decks = JSON.parse(JSON.stringify(firebaseState.decks));
        }
        
        if (firebaseState.hands) {
            hands = JSON.parse(JSON.stringify(firebaseState.hands));
        }
        
        if (firebaseState.graveyards) {
            graveyards = JSON.parse(JSON.stringify(firebaseState.graveyards));
        }
        
        // RENDER ALL BOARD CARDS FROM FIREBASE
        if (firebaseState.boardCards) {
            firebaseState.boardCards.forEach(cardData => {
                const cardId = cardData.id;
                const player = cardData.player;
                
                // Skip if card already exists
                if (document.getElementById(cardId)) return;
                
                const playerArea = document.getElementById(`player${player}Area`);
                if (!playerArea) return;
                
                const cardElement = document.createElement("div");
                cardElement.className = "board-card";
                cardElement.id = cardId;
                cardElement.style.backgroundImage = `url('${cardData.image}')`;
                cardElement.style.left = `${cardData.x}px`;
                cardElement.style.top = `${cardData.y}px`;
                
                if (cardData.color) {
                    cardElement.style.borderColor = cardData.color;
                    cardElement.style.borderWidth = "3px";
                }
                
                if (cardData.rotated) {
                    cardElement.classList.add('rotated');
                }
                
                // Set interaction based on whether it's our card
                if (player === ourPlayer) {
                    cardElement.addEventListener('mousedown', startDrag);
                    cardElement.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showCardZoom(cardData.image, { 
                            type: 'board', 
                            player: player, 
                            cardId: cardId 
                        });
                    });
                    cardElement.style.cursor = 'move';
                    
                    // Add controls for our own cards
                    const controls = document.createElement('div');
                    controls.className = 'card-controls';
                    controls.innerHTML = `
                        <button class="card-control-btn rotate-btn" onclick="rotateCardDirect(this.parentElement.parentElement)">‚Üª</button>
                        <button class="card-control-btn delete-btn" onclick="showDeleteConfirmationForCard('${cardId}')">üóë</button>
                    `;
                    cardElement.appendChild(controls);
                } else {
                    cardElement.style.cursor = 'default';
                    cardElement.title = "Opponent's card";
                    cardElement.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showCardZoom(cardData.image, { 
                            type: 'board', 
                            player: player, 
                            cardId: cardId,
                            isOpponent: true 
                        });
                    });
                }
                
                playerArea.appendChild(cardElement);
                
                boardCards.push({
                    id: cardId,
                    image: cardData.image,
                    player: player,
                    element: cardElement,
                    color: cardData.color,
                    rotated: cardData.rotated || false
                });
            });
        }
        
        // RENDER ALL TOKENS FROM FIREBASE
        if (firebaseState.counterTokens) {
            Object.keys(firebaseState.counterTokens).forEach(player => {
                const playerNum = parseInt(player);
                
                firebaseState.counterTokens[player].forEach(tokenData => {
                    const tokenId = tokenData.id;
                    
                    // Skip if token already exists
                    if (document.getElementById(tokenId)) return;
                    
                    const playerArea = document.getElementById(`player${playerNum}Area`);
                    if (!playerArea) return;
                    
                    const tokenIndex = counterTokens[playerNum]?.length || 0;
                    const tokenColor = TOKEN_COLORS[playerNum][tokenIndex % 4] || '#444';
                    
                    const token = document.createElement("div");
                    token.className = `counter-token token-p${playerNum}-${(tokenIndex % 4) + 1}`;
                    token.id = tokenId;
                    token.style.left = `${tokenData.x || 0}px`;
                    token.style.top = `${tokenData.y || 0}px`;
                    
                    const isOurToken = playerNum === ourPlayer;
                    
                    if (isOurToken) {
                        token.innerHTML = `
                            <div class="counter-value">${tokenData.value || 0}</div>
                            <div class="counter-label">${tokenData.label || 'Token'}</div>
                            <div class="counter-controls">
                                <button class="counter-btn minus" onclick="changeTokenValue('${tokenId}', -1)">-</button>
                                <button class="counter-btn plus" onclick="changeTokenValue('${tokenId}', 1)">+</button>
                            </div>
                        `;
                        token.addEventListener('mousedown', startTokenDrag);
                        token.style.cursor = 'move';
                    } else {
                        token.innerHTML = `
                            <div class="counter-value">${tokenData.value || 0}</div>
                            <div class="counter-label">${tokenData.label || 'Token'}</div>
                        `;
                        token.style.cursor = 'default';
                        token.title = "Opponent's token";
                    }
                    
                    playerArea.appendChild(token);
                    
                    if (!counterTokens[playerNum]) {
                        counterTokens[playerNum] = [];
                    }
                    
                    counterTokens[playerNum].push({
                        id: tokenId,
                        player: playerNum,
                        value: tokenData.value || 0,
                        label: tokenData.label || 'Token',
                        color: tokenColor,
                        element: token,
                        position: { x: tokenData.x || 0, y: tokenData.y || 0 }
                    });
                });
            });
        }
        
        if (firebaseState.lifeZones) {
            lifeZones = JSON.parse(JSON.stringify(firebaseState.lifeZones));
            for (let player of [1, 2]) {
                for (let i = 0; i < 5; i++) {
                    const cardData = lifeZones[player][i];
                    updateLifeZoneDisplay(player, i, cardData, player !== ourPlayer);
                }
            }
        }
        
        // UPDATE ALL COUNTERS
        updateCounters();
        updateDeckVisual(1);
        updateDeckVisual(2);
        
    } catch (error) {
        console.error("‚ùå Error loading game state:", error);
    } finally {
        multiplayer.isSyncing = false;
    }
}

// ============================================================================
// FIXED INITIAL SYNC WHEN PLAYER 2 JOINS
// ============================================================================
function joinGame() {
    const code = document.getElementById('gameCodeInput').value.trim().toUpperCase();
    if (!code || code.length !== 6) {
        showNotification('Invalid Code', 'Please enter a 6-digit code', 'error');
        return;
    }
    
    if (!database) {
        showNotification("Firebase Error", "Database not initialized", "error");
        return;
    }
    
    multiplayer.playerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    multiplayer.playerNumber = 2;
    multiplayer.isHost = false;
    multiplayer.gameId = code;
    
    multiplayer.gameRef = database.ref('games/' + code);
    multiplayer.boardStateRef = database.ref('boardStates/' + code);
    
    multiplayer.gameRef.once('value').then((snapshot) => {
        if (!snapshot.exists()) {
            showNotification('Game Not Found', 'Check the code and try again', 'error');
            return;
        }
        
        const gameData = snapshot.val();
        const players = gameData.players || {};
        const playerCount = Object.keys(players).length;
        
        if (playerCount >= 2) {
            showNotification('Game Full', 'This game already has 2 players', 'error');
            return;
        }
        
        return multiplayer.gameRef.update({
            [`players/${multiplayer.playerId}`]: {
                playerNumber: 2,
                name: "Player 2",
                connected: true,
                lastSeen: Date.now()
            },
            lastUpdate: Date.now(),
            status: 'playing'
        });
    }).then(() => {
        document.getElementById('createGameSection').style.display = 'none';
        document.getElementById('joinGameSection').style.display = 'none';
        document.getElementById('gameInfoSection').style.display = 'block';
        document.getElementById('displayGameCode').textContent = code;
        
        multiplayer.gameRef.on('value', handleGameUpdate);
        multiplayer.boardStateRef.on('value', handleBoardStateUpdate);
        
        showNotification('Joined Game!', 'Connected to host', 'success');
        
        const multiplayerBtn = document.getElementById('multiplayerButton');
        multiplayerBtn.textContent = 'üåê Room: ' + multiplayer.gameId;
        multiplayerBtn.style.background = 'linear-gradient(145deg, #2196F3, #1976D2)';
        
        // LOAD INITIAL GAME STATE
        multiplayer.boardStateRef.once('value').then((snapshot) => {
            if (snapshot.exists()) {
                // Clear local state first
                decks = { 1: [], 2: [] };
                hands = { 1: [], 2: [] };
                graveyards = { 1: [], 2: [] };
                boardCards = [];
                counterTokens = { 1: [], 2: [] };
                lifeZones = { 1: Array(5).fill(null), 2: Array(5).fill(null) };
                
                // Clear all visual elements
                document.querySelectorAll('.board-card').forEach(el => el.remove());
                document.querySelectorAll('.counter-token').forEach(el => el.remove());
                
                // Load from Firebase
                syncGameStateFromFirebase(snapshot.val());
            }
        });
    });
}

// ============================================================================
// FIXED CARD CREATION FUNCTION
// ============================================================================
function createBoardCard(cardData, player) {
    const cardId = cardData.id || `board_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const boardCard = document.createElement("div");
    boardCard.className = "board-card";
    boardCard.id = cardId;
    boardCard.style.backgroundImage = `url('${cardData.image}')`;
    
    if (cardData.color) {
        boardCard.style.borderColor = cardData.color;
        boardCard.style.borderWidth = "3px";
    }
    
    const playerArea = document.getElementById(`player${player}Area`);
    const rect = playerArea.getBoundingClientRect();
    
    const x = 150 + Math.random() * 50;
    const y = Math.random() * (rect.height - 180);
    
    boardCard.style.left = `${x}px`;
    boardCard.style.top = `${y}px`;
    
    // Set interaction based on whether it's our card
    if (!multiplayer.gameId || player === multiplayer.playerNumber) {
        boardCard.addEventListener('mousedown', startDrag);
        boardCard.addEventListener('click', (e) => {
            e.stopPropagation();
            showCardZoom(cardData.image, { 
                type: 'board', 
                player: player, 
                cardId: cardId 
            });
        });
        boardCard.style.cursor = 'move';
        
        // Add controls for our own cards
        const controls = document.createElement('div');
        controls.className = 'card-controls';
        controls.innerHTML = `
            <button class="card-control-btn rotate-btn" onclick="rotateCardDirect(this.parentElement.parentElement)">‚Üª</button>
            <button class="card-control-btn delete-btn" onclick="showDeleteConfirmationForCard('${cardId}')">üóë</button>
        `;
        boardCard.appendChild(controls);
    } else {
        boardCard.style.cursor = 'default';
        boardCard.title = "Opponent's card";
        boardCard.addEventListener('click', (e) => {
            e.stopPropagation();
            showCardZoom(cardData.image, { 
                type: 'board', 
                player: player, 
                cardId: cardId,
                isOpponent: true 
            });
        });
    }
    
    playerArea.appendChild(boardCard);
    
    boardCards.push({
        id: cardId,
        image: cardData.image,
        player: player,
        element: boardCard,
        color: cardData.color,
        rotated: false
    });
    
    // Auto-sync to Firebase if in multiplayer
    if (multiplayer.gameId) {
        setTimeout(() => {
            syncGameStateToFirebase();
        }, 100);
    }
}

// ============================================================================
// FIXED TOKEN FUNCTIONS
// ============================================================================
function addTokenToPlayer(player) {
    // In multiplayer, only allow adding tokens for your own player
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only add tokens for yourself", 'error');
        return;
    }
    
    const playerArea = document.getElementById(`player${player}Area`);
    const tokenCount = counterTokens[player].length;
    
    if (tokenCount >= 4) {
        showNotification("Token Limit", "Maximum 4 tokens per player", 'warning');
        return;
    }
    
    const tokenId = `token_${player}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const tokenColor = TOKEN_COLORS[player][tokenCount];
    const tokenLabel = TOKEN_LABELS[tokenCount] || `Token ${tokenCount + 1}`;
    
    const token = document.createElement("div");
    token.className = `counter-token token-p${player}-${tokenCount + 1}`;
    token.id = tokenId;
    
    const rect = playerArea.getBoundingClientRect();
    const col = tokenCount % 2;
    const row = Math.floor(tokenCount / 2);
    const x = rect.width - 120 + (col * 60);
    const y = rect.height - 120 + (row * 60);
    
    token.style.left = `${x}px`;
    token.style.top = `${y}px`;
    
    // Add controls for our own tokens
    token.innerHTML = `
        <div class="counter-value">0</div>
        <div class="counter-label">${tokenLabel}</div>
        <div class="counter-controls">
            <button class="counter-btn minus" onclick="changeTokenValue('${tokenId}', -1)">-</button>
            <button class="counter-btn plus" onclick="changeTokenValue('${tokenId}', 1)">+</button>
        </div>
    `;
    
    token.addEventListener('mousedown', startTokenDrag);
    token.style.cursor = 'move';
    
    playerArea.appendChild(token);
    
    counterTokens[player].push({
        id: tokenId,
        player: player,
        value: 0,
        label: tokenLabel,
        color: tokenColor,
        element: token,
        position: { x, y }
    });
    
    showNotification("Token Added", `${tokenLabel} token added`, 'success');
    
    // Auto-sync to Firebase if in multiplayer
    if (multiplayer.gameId) {
        setTimeout(() => {
            syncGameStateToFirebase();
        }, 100);
    }
}

// ============================================================================
// FIXED AUTO-SYNC WRAPPER
// ============================================================================
function autoSync(originalFunction) {
    return function(...args) {
        const result = originalFunction.apply(this, args);
        
        // Auto-sync after any game action
        if (multiplayer.gameId && !multiplayer.isSyncing) {
            setTimeout(() => {
                syncGameStateToFirebase();
            }, 100);
        }
        
        return result;
    };
}

// ============================================================================
// FIXED HAND VIEW - ALLOW PLAYER 2 TO VIEW THEIR HAND
// ============================================================================
function viewHand(player) {
    // In multiplayer, check if player is trying to view their own hand
    if (multiplayer.gameId) {
        if (player !== multiplayer.playerNumber) {
            showNotification("Not Allowed", "You can only view your own hand", 'warning');
            return;
        }
    }
    
    const overlay = document.getElementById("handOverlay");
    const container = document.getElementById("handCardsContainer");
    document.getElementById("handTitle").textContent = `Player ${player}'s Hand (${hands[player].length} Cards)`;
    container.innerHTML = "";

    hands[player].forEach(cardData => {
        const card = document.createElement("div");
        card.className = "hand-display-card";
        
        const img = new Image();
        img.onload = function() {
            card.style.backgroundImage = `url('${cardData.image}')`;
        };
        img.onerror = function() {
            card.style.backgroundColor = cardData.color || "#555";
        };
        img.src = cardData.image;
        
        if (cardData.color) {
            card.style.borderColor = cardData.color;
            card.style.borderWidth = "3px";
        }
        
        card.onclick = () => {
            // In multiplayer, only allow viewing own hand cards
            if (multiplayer.gameId && player !== multiplayer.playerNumber) {
                showNotification("Not Allowed", "You can only view cards from your own hand", 'warning');
                return;
            }
            showCardZoom(cardData.image, { 
                type: 'hand', 
                player: player, 
                cardId: cardData.id 
            });
        };
        container.appendChild(card);
    });

    overlay.style.display = "flex";
}

// ============================================================================
// FIXED BOARD STATE UPDATE HANDLER
// ============================================================================
function handleBoardStateUpdate(snapshot) {
    if (!snapshot.exists() || !multiplayer.gameId || multiplayer.isSyncing) return;
    
    const boardState = snapshot.val();
    
    // Skip if this is our own update
    if (boardState.lastUpdatePlayer === multiplayer.playerNumber) {
        return;
    }
    
    // Update game state from Firebase
    syncGameStateFromFirebase(boardState);
}

// ============================================================================
// FIXED GAME FUNCTIONS - ALLOW PLAYER 2 TO USE THEM
// ============================================================================
function drawCardWithAnimation(player) {
    // In multiplayer, check if player is trying to use their own deck
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only draw from your own deck", 'error');
        return;
    }
    
    if (decks[player].length === 0) {
        showNotification("Deck Empty", "Open Shop to add cards to your deck!", 'warning');
        return;
    }
    
    const cardData = decks[player].shift();
    hands[player].push(cardData);
    updateCounters();
    updateDeckVisual(player);
    
    showNotification("Card Drawn", `Player ${player} drew 1 card`, 'success');
    
    // Auto-sync to Firebase if in multiplayer
    if (multiplayer.gameId) {
        setTimeout(() => {
            syncGameStateToFirebase();
        }, 100);
    }
}

function openFromDeck(player) {
    // In multiplayer, check if player is trying to use their own deck
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only open from your own deck", 'error');
        return;
    }
    
    if (decks[player].length === 0) {
        showNotification("Deck Empty", "No cards in deck!", 'warning');
        return;
    }
    
    const cardData = decks[player].shift();
    createBoardCard(cardData, player);
    updateCounters();
    updateDeckVisual(player);
    
    showNotification("Card Opened", `Player ${player} opened a card`, 'success');
}

function shuffleDeckWithAnimation(player) {
    // In multiplayer, check if player is trying to shuffle their own deck
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only shuffle your own deck", 'error');
        return;
    }
    
    if (decks[player].length === 0) {
        showNotification("Deck Empty", "No cards to shuffle!", 'warning');
        return;
    }
    
    decks[player].sort(() => Math.random() - 0.5);
    updateDeckVisual(player);
    
    showNotification("Deck Shuffled", `Player ${player}'s deck shuffled`, 'success');
    
    // Auto-sync to Firebase if in multiplayer
    if (multiplayer.gameId) {
        setTimeout(() => {
            syncGameStateToFirebase();
        }, 100);
    }
}

// ============================================================================
// FIXED INITIALIZATION
// ============================================================================
window.addEventListener('load', function() {
    const urlParams = new URLSearchParams(window.location.search);
    const gameCode = urlParams.get('game');
    
    if (gameCode && gameCode.length === 6) {
        document.getElementById('gameCodeInput').value = gameCode;
        showMultiplayerMenu();
        
        setTimeout(() => {
            if (database) {
                joinGame();
            }
        }, 1000);
    }
    
    updateCounters();
    initializeLifeZones();
    setupShop();
});

// Apply auto-sync to key functions
drawCardWithAnimation = autoSync(drawCardWithAnimation);
shuffleDeckWithAnimation = autoSync(shuffleDeckWithAnimation);
openFromDeck = autoSync(openFromDeck);
createBoardCard = autoSync(createBoardCard);
addTokenToPlayer = autoSync(addTokenToPlayer);
playToBoard = autoSync(playToBoard);
moveToHand = autoSync(moveToHand);
moveToGY = autoSync(moveToGY);
addToDeck = autoSync(addToDeck);
rotateCard = autoSync(rotateCard);
rotateCardDirect = autoSync(rotateCardDirect);
resetPlayerTokens = autoSync(resetPlayerTokens);
shuffleLifeZones = autoSync(shuffleLifeZones);
removeFromLifeZone = autoSync(removeFromLifeZone);
flipLifeZoneCard = autoSync(flipLifeZoneCard);
addToLifeZone = autoSync(addToLifeZone);
    
    dragState.isDragging = false;
    dragState.card = null;
    dragState.originalCard = null;
    dragState.draggingToken = false;
    
    document.removeEventListener('mousemove', handleTokenMouseMove);
    document.removeEventListener('mouseup', handleTokenMouseUp);


// ============================================================================
// LIFE ZONE FUNCTIONS
// ============================================================================
function initializeLifeZones() {
    for (let player of [1, 2]) {
        const container = document.getElementById(`lifeZones${player}`);
        container.innerHTML = '';
        
        for (let i = 0; i < 5; i++) {
            const zone = document.createElement('div');
            zone.className = 'life-zone';
            zone.id = `lifeZone_${player}_${i}`;
            zone.setAttribute('data-player', player);
            zone.setAttribute('data-index', i);
            
            const number = document.createElement('div');
            number.className = 'life-zone-number';
            number.textContent = `L${i + 1}`;
            zone.appendChild(number);
            
            zone.addEventListener('dragover', handleLifeZoneDragOver);
            zone.addEventListener('drop', handleLifeZoneDrop);
            
            container.appendChild(zone);
        }
    }
}

function handleLifeZoneDragOver(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (dragState.isDragging && !dragState.draggingToken) {
        e.currentTarget.style.borderColor = '#9fea5f';
        e.currentTarget.style.boxShadow = '0 0 10px rgba(126, 211, 33, 0.5)';
    }
}

function handleLifeZoneDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (!dragState.isDragging || dragState.draggingToken) return;
    
    const zone = e.currentTarget;
    const player = parseInt(zone.getAttribute('data-player'));
    const index = parseInt(zone.getAttribute('data-index'));
    
    zone.style.borderColor = '';
    zone.style.boxShadow = '';
    
    if (dragState.originalCard && dragState.originalCard.classList.contains('board-card')) {
        const cardId = dragState.originalCard.id;
        const cardIndex = boardCards.findIndex(card => card.id === cardId);
        
        if (cardIndex > -1) {
            const cardData = boardCards[cardIndex];
            
            if (lifeZones[player][index]) {
                returnCardFromLifeZone(player, index);
            }
            
            boardCards.splice(cardIndex, 1);
            dragState.originalCard.remove();
            
            lifeZones[player][index] = {
                ...cardData,
                flipped: false
            };
            updateLifeZoneDisplay(player, index, lifeZones[player][index], player !== multiplayer.playerNumber);
            
            showNotification("Card Added to Life Zone", `Card added to Life Zone ${index + 1} for Player ${player}`, 'success', 3000);
            return;
        }
    }
    
    if (currentZoomSource && currentZoomSource.type === 'hand') {
        const player = currentZoomSource.player;
        const cardId = currentZoomSource.cardId;
        const cardIndex = hands[player].findIndex(card => card.id === cardId);
        
        if (cardIndex > -1) {
            const cardData = hands[player][cardIndex];
            
            if (lifeZones[player][index]) {
                showNotification("Life Zone Full", `Life Zone ${index + 1} already has a card!`, 'warning', 3000);
                return;
            }
            
            hands[player].splice(cardIndex, 1);
            
            lifeZones[player][index] = {
                ...cardData,
                flipped: false
            };
            updateLifeZoneDisplay(player, index, lifeZones[player][index], player !== multiplayer.playerNumber);
            
            updateCounters();
            closeZoomOnly();
            
            showNotification("Card Added to Life Zone", `Card added to Life Zone ${index + 1} for Player ${player}`, 'success', 3000);
            return;
        }
    }
}

function updateLifeZoneDisplay(player, index, cardData, isOpponent = false) {
    const zone = document.getElementById(`lifeZone_${player}_${index}`);
    if (!zone) return;
    
    zone.innerHTML = '';
    
    const number = document.createElement('div');
    number.className = 'life-zone-number';
    number.textContent = `L${index + 1}`;
    zone.appendChild(number);
    
    if (cardData) {
        zone.classList.add('has-card');
        
        const cardDisplay = document.createElement('div');
        cardDisplay.className = 'life-zone-card';
        
        if (cardData.flipped) {
            cardDisplay.classList.add('flipped');
        } else {
            cardDisplay.style.backgroundImage = `url('${cardData.image}')`;
        }
        
        if (isOpponent) {
            cardDisplay.title = "Opponent's card";
            cardDisplay.style.cursor = 'default';
        } else {
            cardDisplay.title = `Life Zone ${index + 1}: Click to view`;
            cardDisplay.style.cursor = 'pointer';
        }
        
        if (!isOpponent) {
            cardDisplay.onclick = (e) => {
                e.stopPropagation();
                if (cardData.flipped) {
                    showCardZoom(cardData.image, {
                        type: 'lifezone',
                        player: player,
                        zoneIndex: index,
                        cardId: cardData.id,
                        flipped: true
                    });
                } else {
                    showCardZoom(cardData.image, {
                        type: 'lifezone',
                        player: player,
                        zoneIndex: index,
                        cardId: cardData.id,
                        flipped: false
                    });
                }
            };
        }
        
        zone.appendChild(cardDisplay);
        
        if (!isOpponent) {
            const flipBtn = document.createElement('button');
            flipBtn.className = 'life-zone-flip-btn';
            flipBtn.innerHTML = '‚Üª';
            flipBtn.title = 'Flip card';
            flipBtn.onclick = (e) => {
                e.stopPropagation();
                flipLifeZoneCardDirect(player, index);
            };
            zone.appendChild(flipBtn);
        }
        
    } else {
        zone.classList.remove('has-card');
    }
}

function returnCardFromLifeZone(player, index) {
    const cardData = lifeZones[player][index];
    if (!cardData) return;
    
    const cardDataForBoard = { ...cardData, flipped: false, rotated: false };
    createBoardCard(cardDataForBoard, player);
    lifeZones[player][index] = null;
    updateLifeZoneDisplay(player, index, null, player !== multiplayer.playerNumber);
    
    showNotification("Card Returned to Board", `Card returned from Life Zone ${index + 1} to board`, 'info', 3000);
}
returnCardFromLifeZone = autoSync(returnCardFromLifeZone);

function shuffleLifeZones(player) {
    if (multiplayer.gameId && player !== multiplayer.playerNumber) return;
    
    const zones = lifeZones[player];
    const cards = zones.filter(card => card !== null);
    
    if (cards.length <= 1) {
        showNotification("Not Enough Cards", `Player ${player} needs at least 2 cards in life zones to shuffle!`, 'warning', 3000);
        return;
    }
    
    for (let i = cards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [cards[i], cards[j]] = [cards[j], cards[i]];
    }
    
    let cardIndex = 0;
    for (let i = 0; i < zones.length; i++) {
        if (zones[i] !== null) {
            lifeZones[player][i] = cards[cardIndex];
            updateLifeZoneDisplay(player, i, cards[cardIndex], player !== multiplayer.playerNumber);
            cardIndex++;
        }
    }
    
    showNotification("Life Zones Shuffled", `Player ${player}'s life zones have been shuffled!`, 'success', 3000);
}
shuffleLifeZones = autoSync(shuffleLifeZones);

function removeFromLifeZone() {
    if (!currentZoomSource || currentZoomSource.type !== 'lifezone') return;
    
    const player = currentZoomSource.player;
    const zoneIndex = currentZoomSource.zoneIndex;
    
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only remove cards from your own life zones", 'error');
        return;
    }
    
    const cardData = lifeZones[player][zoneIndex];
    if (cardData) {
        setTimeout(() => {
            const userChoice = confirm(`Remove card from Life Zone ${zoneIndex + 1}.\nOK = Put in hand\nCancel = Put on board`);
            
            if (userChoice) {
                hands[player].push({...cardData, flipped: false, rotated: false});
                showNotification("Card Moved to Hand", `Card moved from Life Zone ${zoneIndex + 1} to hand`, 'success', 2000);
            } else {
                createBoardCard({...cardData, flipped: false, rotated: false}, player);
                showNotification("Card Moved to Board", `Card moved from Life Zone ${zoneIndex + 1} to board`, 'success', 2000);
            }
            
            lifeZones[player][zoneIndex] = null;
            updateLifeZoneDisplay(player, zoneIndex, null, player !== multiplayer.playerNumber);
            updateCounters();
            closeZoomOnly();
        }, 100);
    }
}
removeFromLifeZone = autoSync(removeFromLifeZone);

function flipLifeZoneCard() {
    if (!currentZoomSource || currentZoomSource.type !== 'lifezone') return;
    
    const player = currentZoomSource.player;
    const zoneIndex = currentZoomSource.zoneIndex;
    
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only flip cards in your own life zones", 'error');
        return;
    }
    
    const cardData = lifeZones[player][zoneIndex];
    if (cardData) {
        cardData.flipped = !cardData.flipped;
        updateLifeZoneDisplay(player, zoneIndex, cardData, player !== multiplayer.playerNumber);
        closeZoomOnly();
        
        const status = cardData.flipped ? "flipped face-down" : "flipped face-up";
        showNotification("Card Flipped", `Life Zone ${zoneIndex + 1} card ${status}`, 'info', 2000);
    }
}
flipLifeZoneCard = autoSync(flipLifeZoneCard);

function addToLifeZone(player) {
    if (!currentShopImage) {
        showNotification("No Card Selected", "Please select a card first!", 'warning', 3000);
        return;
    }
    
    const emptyIndex = lifeZones[player].findIndex(card => card === null);
    
    if (emptyIndex === -1) {
        showNotification("Life Zones Full", `Player ${player} has no empty life zones!`, 'warning', 3000);
        return;
    }
    
    const cardId = `life_${player}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    let categoryColor = "#7ED321";
    for (const [categoryId, category] of Object.entries(CARD_CATEGORIES)) {
        if (currentShopImage.includes(category.prefix)) {
            categoryColor = category.color;
            break;
        }
    }
    
    const cardData = {
        image: currentShopImage,
        id: cardId,
        color: categoryColor,
        flipped: false
    };
    
    lifeZones[player][emptyIndex] = cardData;
    updateLifeZoneDisplay(player, emptyIndex, cardData, player !== multiplayer.playerNumber);
    
    showNotification("Card Added to Life Zone", `Card added to Life Zone ${emptyIndex + 1} for Player ${player}`, 'success', 3000);
    currentShopImage = null;
}
addToLifeZone = autoSync(addToLifeZone);

// ============================================================================
// VIEW FUNCTIONS
// ============================================================================
function viewHand(player) {
    if (multiplayer.gameId && player !== multiplayer.playerNumber) {
        showNotification("Not Allowed", "You can only view your own hand", 'warning');
        return;
    }
    
    const overlay = document.getElementById("handOverlay");
    const container = document.getElementById("handCardsContainer");
    document.getElementById("handTitle").textContent = `Player ${player}'s Hand (${hands[player].length} Cards)`;
    container.innerHTML = "";

    hands[player].forEach(cardData => {
        const card = document.createElement("div");
        card.className = "hand-display-card";
        
        const img = new Image();
        img.onload = function() {
            card.style.backgroundImage = `url('${cardData.image}')`;
        };
        img.onerror = function() {
            card.style.backgroundColor = cardData.color || "#555";
        };
        img.src = cardData.image;
        
        if (cardData.color) {
            card.style.borderColor = cardData.color;
            card.style.borderWidth = "3px";
        }
        
        card.onclick = () => showCardZoom(cardData.image, { 
            type: 'hand', 
            player: player, 
            cardId: cardData.id 
        });
        container.appendChild(card);
    });

    overlay.style.display = "flex";
}

function closeHand() { 
    document.getElementById("handOverlay").style.display = "none"; 
}

function viewDeck(player) {
    const overlay = document.getElementById("deckOverlay");
    const container = document.getElementById("deckCardsContainer");
    document.getElementById("deckTitle").textContent = `Player ${player}'s Deck (${decks[player].length} Cards)`;
    container.innerHTML = "";

    decks[player].forEach((cardData, index) => {
        const card = document.createElement("div");
        card.className = "hand-display-card deck-card";
        
        const img = new Image();
        img.onload = function() {
            card.style.backgroundImage = `url('${cardData.image}')`;
        };
        img.onerror = function() {
            card.style.backgroundColor = cardData.color || "#555";
        };
        img.src = cardData.image;
        
        if (cardData.color) {
            card.style.borderColor = cardData.color;
            card.style.borderWidth = "3px";
        }
        
        const positionBadge = document.createElement("div");
        positionBadge.style.position = "absolute";
        positionBadge.style.top = "5px";
        positionBadge.style.left = "5px";
        positionBadge.style.background = "rgba(0,0,0,0.7)";
        positionBadge.style.color = "white";
        positionBadge.style.padding = "2px 6px";
        positionBadge.style.borderRadius = "10px";
        positionBadge.style.fontSize = "10px";
        positionBadge.style.fontWeight = "bold";
        positionBadge.textContent = `#${index + 1}`;
        card.appendChild(positionBadge);
        
        card.onclick = () => {
            showCardZoom(cardData.image, { 
                type: 'deck', 
                player: player, 
                cardIndex: index 
            });
        };
        
        container.appendChild(card);
    });

    overlay.style.display = "flex";
}

function closeDeck() { 
    document.getElementById("deckOverlay").style.display = "none"; 
}

function viewGraveyard(player) {
    const overlay = document.getElementById("graveyardOverlay");
    const container = document.getElementById("graveyardCardsContainer");
    document.getElementById("graveyardTitle").textContent = `Player ${player}'s Graveyard (${graveyards[player].length} Cards)`;
    container.innerHTML = "";

    graveyards[player].forEach((cardData, index) => {
        const card = document.createElement("div");
        card.className = "hand-display-card gy-card";
        
        const img = new Image();
        img.onload = function() {
            card.style.backgroundImage = `url('${cardData.image}')`;
        };
        img.onerror = function() {
            card.style.backgroundColor = cardData.color || "#555";
        };
        img.src = cardData.image;
        
        if (cardData.color) {
            card.style.borderColor = cardData.color;
            card.style.borderWidth = "3px";
        }
        
        card.onclick = () => {
            showCardZoom(cardData.image, { 
                type: 'graveyard', 
                player: player, 
                cardIndex: index 
            });
        };
        
        container.appendChild(card);
    });

    overlay.style.display = "flex";
}

function closeGraveyard() { 
    document.getElementById("graveyardOverlay").style.display = "none"; 
}

// ============================================================================
// OTHER FUNCTIONS
// ============================================================================
function rotateCard() {
    if (!currentZoomSource || currentZoomSource.type !== 'board') return;
    
    const cardId = currentZoomSource.cardId;
    const cardElement = document.getElementById(cardId);
    if (cardElement) {
        rotateCardDirect(cardElement);
        closeZoomOnly();
    }
}

function rotateCardDirect(cardElement) {
    if (!cardElement) return;
    
    cardElement.classList.toggle('rotated');
    
    const cardIndex = boardCards.findIndex(c => c.element === cardElement);
    if (cardIndex > -1) {
        boardCards[cardIndex].rotated = !boardCards[cardIndex].rotated;
    }
}
rotateCard = autoSync(rotateCard);
rotateCardDirect = autoSync(rotateCardDirect);

function showDeleteConfirmation() {
    if (!currentZoomSource || currentZoomSource.type !== 'board') return;
    
    const cardId = currentZoomSource.cardId;
    const cardElement = document.getElementById(cardId);
    
    if (cardElement) {
        cardToDelete = cardId;
        document.getElementById('confirmDeleteOverlay').style.display = 'flex';
    }
}

function showDeleteConfirmationForCard(cardId) {
    const cardElement = document.getElementById(cardId);
    if (cardElement) {
        cardToDelete = cardId;
        document.getElementById('confirmDeleteOverlay').style.display = 'flex';
    }
}

function confirmDeleteCard() {
    if (!cardToDelete) {
        cancelDeleteCard();
        return;
    }
    
    const cardIndex = boardCards.findIndex(card => card.id === cardToDelete);
    
    if (cardIndex > -1) {
        const cardElement = document.getElementById(cardToDelete);
        
        if (cardElement) {
            cardElement.classList.add('delete-animation');
            
            setTimeout(() => {
                cardElement.remove();
                boardCards.splice(cardIndex, 1);
                document.getElementById('confirmDeleteOverlay').style.display = 'none';
                closeZoomOnly();
                showNotification("Card Deleted", "Card has been permanently deleted!", 'info', 3000);
            }, 500);
        }
    }
    
    cardToDelete = null;
}
confirmDeleteCard = autoSync(confirmDeleteCard);

function cancelDeleteCard() {
    cardToDelete = null;
    document.getElementById('confirmDeleteOverlay').style.display = 'none';
}

function flipLifeZoneCardDirect(player, index) {
    if (multiplayer.gameId && player !== multiplayer.playerNumber) return;
    
    const cardData = lifeZones[player][index];
    if (cardData) {
        cardData.flipped = !cardData.flipped;
        updateLifeZoneDisplay(player, index, cardData, player !== multiplayer.playerNumber);
        
        const status = cardData.flipped ? "flipped face-down" : "flipped face-up";
        showNotification("Card Flipped", `Life Zone ${index + 1} card ${status}`, 'info', 2000);
    }
}
flipLifeZoneCardDirect = autoSync(flipLifeZoneCardDirect);

// ============================================================================
// INITIALIZATION
// ============================================================================
window.addEventListener('load', function() {
    const urlParams = new URLSearchParams(window.location.search);
    const gameCode = urlParams.get('game');
    
    if (gameCode && gameCode.length === 6) {
        document.getElementById('gameCodeInput').value = gameCode;
        showMultiplayerMenu();
        
        setTimeout(() => {
            if (database) {
                joinGame();
            }
        }, 500);
    }
    
    updateCounters();
    initializeLifeZones();
    setupShop();
});

// ============================================================================
// EVENT LISTENERS
// ============================================================================
document.getElementById("addToDeckP1").onclick = () => addToDeck(1);
document.getElementById("addToDeckP2").onclick = () => addToDeck(2);
document.getElementById("playToBoard").onclick = playToBoard;
document.getElementById("moveToHand").onclick = moveToHand;
document.getElementById("moveToGY").onclick = moveToGY;
document.getElementById('addToP1DeckQty').onclick = () => addMultipleToDeck(1);
document.getElementById('addToP2DeckQty').onclick = () => addMultipleToDeck(2);

// ============================================================================
// KEYBOARD SHORTCUTS
// ============================================================================
document.addEventListener('keydown', function(e) {
    if (dragState.isDragging && dragState.lastDraggedCard) {
        const cardId = dragState.lastDraggedCard.id;
        const cardIndex = boardCards.findIndex(c => c.id === cardId);
        
        if (cardIndex > -1) {
            const cardElement = boardCards[cardIndex].element;
            
            switch(e.key.toLowerCase()) {
                case 'r':
                    e.preventDefault();
                    rotateCardDirect(cardElement);
                    break;
                    
                case 'delete':
                case 'd':
                    e.preventDefault();
                    showDeleteConfirmationForCard(cardElement.id);
                    break;
                    
                case 'escape':
                    e.preventDefault();
                    dragState.isDragging = false;
                    if (dragState.card) dragState.card.remove();
                    if (dragState.originalCard) dragState.originalCard.style.visibility = "visible";
                    break;
            }
        }
    }
});

// ============================================================================
// ANIMATION STYLES
// ============================================================================
const style = document.createElement('style');
style.textContent = `
@keyframes shuffleSuccess {
    0% { box-shadow: 0 0 0 0 rgba(0, 170, 170, 0.7); }
    70% { box-shadow: 0 0 0 20px rgba(0, 170, 170, 0); }
    100% { box-shadow: 0 0 0 0 rgba(0, 170, 170, 0); }
}
`;
document.head.appendChild(style);
</script>
</body>
</html>
