<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Board Game - Real-Time Multiplayer</title>
    <!-- Add Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', sans-serif;
            background: #1b1b1b;
            color: white;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #board {
            position: relative;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .player-area {
            flex: 1;
            display: flex;
            position: relative;
            border-top: 2px solid #444;
            border-bottom: 2px solid #444;
            margin: 2px 0;
            overflow: hidden;
        }

        .card {
            width: 120px;
            height: 180px;
            border-radius: 6px;
            background-color: #555;
            border: 2px solid #000;
            background-size: cover;
            background-position: center;
            cursor: grab;
            flex-shrink: 0;
            transition: transform 0.1s, box-shadow 0.2s;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }
        .card.on-board { position: absolute; }
        .card.dragging { 
            opacity: 0.8; 
            cursor: grabbing; 
            pointer-events: none; 
            z-index: 9999 !important; 
            position: fixed !important; 
            transform: translate(-50%, -50%);
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        .controls { 
            position: absolute; 
            left: 160px;
            z-index: 100; 
            pointer-events: auto; 
            background: rgba(0,0,0,0.5); 
            padding: 5px; 
            border-radius: 4px; 
        }
        #p2Controls { top: 10px; }
        #p1Controls { bottom: 10px; }

        .token-controls {
            position: absolute;
            bottom: 5px;
            right: 5px;
            z-index: 100;
            pointer-events: auto;
            background: rgba(0,0,0,0.7);
            padding: 3px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 60px;
            border: 1px solid #666;
        }
        
        .token-controls-top {
            position: absolute;
            top: 5px;
            right: 5px;
            z-index: 100;
            pointer-events: auto;
            background: rgba(0,0,0,0.7);
            padding: 3px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 60px;
            border: 1px solid #666;
        }

        button { margin: 2px; padding: 6px 12px; cursor: pointer; background: #444; color: #fff; border: 1px solid #666; border-radius: 4px; }
        button:hover { background: #666; }
        #shopButton { position: absolute; top: 50%; right: 10px; transform: translateY(-50%); z-index: 200; background: #d4af37; color: #000; font-weight: bold; }

        .small-token-btn {
            background: #6a0dad;
            color: white;
            border: 1px solid #8a2be2;
            border-radius: 3px;
            padding: 2px 4px;
            font-size: 10px;
            cursor: pointer;
            margin: 1px;
            width: 100%;
            text-align: center;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .small-token-btn:hover {
            background: #8a2be2;
            transform: scale(1.05);
        }
        
        .small-token-reset-btn {
            background: #d35400;
            color: white;
            border: 1px solid #e67e22;
            border-radius: 3px;
            padding: 2px 4px;
            font-size: 10px;
            cursor: pointer;
            margin: 1px;
            width: 100%;
            text-align: center;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .small-token-reset-btn:hover {
            background: #e67e22;
            transform: scale(1.05);
        }
        
        .token-controls-label {
            font-size: 9px;
            text-align: center;
            color: #aaa;
            margin-bottom: 1px;
            font-weight: bold;
            border-bottom: 1px solid #444;
            padding-bottom: 2px;
        }

        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10050;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 300px;
            pointer-events: none;
        }
        
        .notification {
            background: rgba(0, 0, 0, 0.85);
            border-left: 4px solid #4A90E2;
            border-radius: 6px;
            padding: 12px 15px;
            color: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideInRight 0.3s ease-out;
            transform: translateX(0);
            opacity: 1;
            transition: all 0.3s ease;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        
        .notification.fade-out {
            opacity: 0;
            transform: translateX(100%);
        }
        
        .notification.success {
            border-left-color: #7ED321;
        }
        
        .notification.warning {
            border-left-color: #F5A623;
        }
        
        .notification.error {
            border-left-color: #D0021B;
        }
        
        .notification.info {
            border-left-color: #4A90E2;
        }
        
        .notification-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .notification-message {
            font-size: 13px;
            line-height: 1.4;
            color: #ddd;
        }
        
        .notification-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: #aaa;
            font-size: 16px;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }
        
        .notification-close:hover {
            background: rgba(255,255,255,0.1);
            color: white;
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .gy-shortcut-btn {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(40, 167, 69, 0.9);
            color: white;
            border: 1px solid #28a745;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 10px;
            cursor: pointer;
            z-index: 25;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            min-width: 40px;
            text-align: center;
        }
        
        .gy-shortcut-btn:hover {
            background: rgba(40, 167, 69, 1);
            transform: translateX(-50%) scale(1.1);
        }
        
        .board-card:hover .gy-shortcut-btn {
            opacity: 1;
        }
        
        .gy-shortcut-btn:active {
            transform: translateX(-50%) scale(0.95);
        }

        .hand-display-card, .shop-card { 
            width: 120px; 
            height: 180px; 
            border-radius: 6px; 
            background-size: cover; 
            background-position: center; 
            background-color: #555;
            border: 2px solid #333; 
            cursor: pointer; 
            transition: border-color 0.2s; 
            position: relative;
            overflow: hidden;
        }
        .hand-display-card:hover, .shop-card:hover { border-color: yellow; }

        .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: none; z-index: 10000; justify-content: center; align-items: center; flex-direction: column; }

        #shopWindow { width: 80%; height: 80%; background: #111; border: 2px solid #444; padding: 20px; border-radius: 8px; display: flex; flex-direction: column; }
        #shopCards { margin-top: 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 10px; overflow-y: auto; }
        .category-buttons { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .category-btn { background: #333; color: white; border: 1px solid #555; padding: 8px 16px; border-radius: 4px; cursor: pointer; }
        .category-btn:hover { background: #555; }
        .category-btn.active { background: #d4af37; color: #000; font-weight: bold; border-color: #ffd700; }

        #zoomOverlay { z-index: 10001; }
        #zoomCard { width: 360px; height: 540px; background-size: cover; background-position: center; border: 4px solid #fff; border-radius: 12px; margin-bottom: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.8); background-color: #555; }

        #handOverlay { z-index: 10000; }
        #handOverlayContent { background: #222; padding: 20px; border-radius: 8px; max-width: 90%; max-height: 90%; overflow: auto; }
        #handCardsContainer { display: grid; grid-template-columns: repeat(auto-fill, 120px); gap: 15px; margin-top: 20px; }

        .graveyard { 
            width: 140px; 
            height: 200px; 
            border: 2px dashed #888; 
            border-radius: 8px; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            flex-direction: column; 
            cursor: pointer; 
            text-align: center; 
            position: absolute; 
            right: 20px; 
            top: 50%; 
            transform: translateY(-50%); 
        }
        .graveyard:hover { border-color: yellow; }
        .graveyard-count { font-size: 16px; margin-top: 5px; }

        .deck-container {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 140px;
        }
        
        .deck-zone { 
            width: 140px; 
            height: 200px; 
            border: 2px dashed #666; 
            border-radius: 8px; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            flex-direction: column; 
            cursor: pointer; 
            text-align: center; 
            background: rgba(50, 50, 50, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .deck-visual {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .deck-card-stack {
            position: relative;
            width: 120px;
            height: 180px;
        }
        
        .deck-card-layer {
            position: absolute;
            width: 120px;
            height: 180px;
            border-radius: 6px;
            background: linear-gradient(145deg, #1a1a1a, #2c2c2c);
            border: 2px solid #444;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .deck-card-layer::before {
            content: '';
            position: absolute;
            width: 100px;
            height: 150px;
            background: linear-gradient(135deg, #333 0%, #555 50%, #333 100%);
            border-radius: 4px;
            border: 2px solid #666;
        }
        
        .deck-card-layer::after {
            content: 'DECK';
            position: absolute;
            color: #aaa;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
        
        .deck-card-layer:nth-child(1) { 
            transform: translate(0px, 0px); 
            background: linear-gradient(145deg, #1a1a1a, #2c2c2c);
        }
        .deck-card-layer:nth-child(2) { 
            transform: translate(2px, 2px); 
            background: linear-gradient(145deg, #222, #333);
        }
        .deck-card-layer:nth-child(3) { 
            transform: translate(4px, 4px); 
            background: linear-gradient(145deg, #2a2a2a, #3c3c3c);
        }
        .deck-card-layer:nth-child(4) { 
            transform: translate(6px, 6px); 
            background: linear-gradient(145deg, #333, #444);
        }
        .deck-card-layer:nth-child(5) { 
            transform: translate(8px, 8px); 
            background: linear-gradient(145deg, #3a3a3a, #4c4c4c);
        }
        
        .deck-zone.empty .deck-card-layer {
            display: none;
        }
        
        .deck-zone:hover { 
            border-color: cyan; 
            transform: translateY(-2px);
            transition: all 0.2s;
        }
        
        .deck-count { 
            font-size: 24px; 
            font-weight: bold;
            color: cyan;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 20px;
            min-width: 40px;
            text-align: center;
        }
        
        .deck-label {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
            color: cyan;
            text-align: center;
        }
        
        .deck-shuffle-btn {
            background: linear-gradient(145deg, #008080, #00aaaa);
            color: white;
            border: none;
            border-radius: 20px;
            padding: 6px 12px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            margin-top: 5px;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        
        .deck-shuffle-btn:hover {
            background: linear-gradient(145deg, #00aaaa, #00cccc);
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.4);
        }
        
        .deck-shuffle-btn:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .deck-shuffle-btn.shuffling {
            background: linear-gradient(145deg, #ff9900, #ffcc00);
            animation: shufflePulse 0.5s infinite alternate;
        }
        
        @keyframes shufflePulse {
            from { box-shadow: 0 0 5px rgba(255, 153, 0, 0.5); }
            to { box-shadow: 0 0 15px rgba(255, 153, 0, 0.8); }
        }
        
        .draw-animation {
            position: fixed;
            width: 120px;
            height: 180px;
            border-radius: 6px;
            background: linear-gradient(145deg, #1a1a1a, #2c2c2c);
            border: 2px solid #444;
            z-index: 99999;
            pointer-events: none;
            animation: drawCardMove 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .draw-animation::before {
            content: '';
            position: absolute;
            width: 100px;
            height: 150px;
            background: linear-gradient(135deg, #333 0%, #555 50%, #333 100%);
            border-radius: 4px;
            border: 2px solid #666;
        }
        
        .draw-animation::after {
            content: 'DRAW';
            position: absolute;
            color: #aaa;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
        
        @keyframes drawCardMove {
            0% {
                transform: scale(0.8) rotate(-10deg);
                opacity: 0;
            }
            20% {
                opacity: 1;
                transform: scale(1.1) rotate(5deg);
            }
            100% {
                transform: translate(var(--target-x), var(--target-y)) scale(1) rotate(0deg);
                opacity: 0;
            }
        }
        
        .open-btn {
            background: linear-gradient(145deg, #008080, #00aaaa);
            color: white;
            border: none;
            border-radius: 20px;
            padding: 8px 16px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            text-align: center;
            margin-top: 5px;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }
        
        .open-btn:hover {
            background: linear-gradient(145deg, #00aaaa, #00cccc);
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.4);
        }
        
        .open-btn:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .open-btn.opening {
            background: linear-gradient(145deg, #00cccc, #00eeee);
            animation: openPulse 0.3s infinite alternate;
        }
        
        @keyframes openPulse {
            from { box-shadow: 0 0 5px rgba(0, 204, 204, 0.5); }
            to { box-shadow: 0 0 15px rgba(0, 204, 204, 0.8); }
        }

        .board-card {
            position: absolute;
            width: 120px;
            height: 180px;
            border-radius: 6px;
            background-size: cover;
            background-position: center;
            cursor: move;
            border: 2px solid #000;
            z-index: 10;
            background-color: #555;
            user-select: none;
            transition: transform 0.3s ease;
        }
        
        .board-card.rotated {
            transform: rotate(-90deg);
            border-color: #ff9900;
        }
        
        .card-controls {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .board-card:hover .card-controls {
            opacity: 1;
        }
        
        .card-control-btn {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid #666;
            border-radius: 3px;
            padding: 3px 8px;
            font-size: 11px;
            cursor: pointer;
            min-width: 40px;
            text-align: center;
        }
        
        .card-control-btn:hover {
            background: rgba(50, 50, 50, 0.9);
        }
        
        .rotate-btn {
            background: rgba(255, 153, 0, 0.8);
        }
        
        .delete-btn {
            background: rgba(255, 68, 68, 0.8);
        }
        
        .delete-btn:hover {
            background: rgba(255, 100, 100, 0.9);
        }
        
        .delete-animation {
            animation: deleteCard 0.5s ease-out forwards;
            pointer-events: none;
        }
        
        @keyframes deleteCard {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(0.5);
                opacity: 0.5;
            }
            100% {
                transform: scale(0) rotate(180deg);
                opacity: 0;
            }
        }
        
        .confirm-delete-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 20000;
            justify-content: center;
            align-items: center;
        }
        
        .confirm-delete-box {
            background: #222;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
            border: 2px solid #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.3);
        }
        
        .confirm-delete-box h3 {
            color: #ff6b6b;
            margin-top: 0;
        }
        
        .confirm-delete-box p {
            margin: 20px 0;
            color: #ddd;
        }
        
        .confirm-delete-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }
        
        .confirm-delete-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            min-width: 100px;
        }
        
        .confirm-delete-btn:hover {
            background: #ff6666;
        }
        
        .cancel-delete-btn {
            background: #666;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            min-width: 100px;
        }
        
        .cancel-delete-btn:hover {
            background: #888;
        }
        
        .counter-token {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(145deg, #2c2c2c, #1a1a1a);
            border: 2px solid #444;
            cursor: move;
            z-index: 30;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            transition: transform 0.2s, box-shadow 0.2s;
            user-select: none;
        }
        
        .counter-token:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
            border-color: #666;
        }
        
        .counter-token.dragging {
            opacity: 0.8;
            cursor: grabbing;
            pointer-events: none;
            z-index: 9999 !important;
            position: fixed !important;
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.5);
        }
        
        .counter-value {
            font-size: 18px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .counter-label {
            font-size: 8px;
            color: #aaa;
            margin-top: 1px;
            text-align: center;
            max-width: 45px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .counter-controls {
            display: flex;
            gap: 3px;
            margin-top: 2px;
        }
        
        .counter-btn {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #444;
            border: none;
            color: white;
            font-size: 11px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            padding: 0;
        }
        
        .counter-btn:hover {
            background: #666;
        }
        
        .counter-btn.minus {
            background: #ff4444;
        }
        
        .counter-btn.plus {
            background: #44ff44;
        }
        
        .counter-btn.minus:hover {
            background: #ff6666;
        }
        
        .counter-btn.plus:hover {
            background: #66ff66;
        }
        
        .token-p1-1 { border-color: #ff6b6b; }
        .token-p1-1 .counter-value { color: #ff6b6b; }
        
        .token-p1-2 { border-color: #4ecdc4; }
        .token-p1-2 .counter-value { color: #4ecdc4; }
        
        .token-p1-3 { border-color: #ffe66d; }
        .token-p1-3 .counter-value { color: #ffe66d; }
        
        .token-p1-4 { border-color: #95e1d3; }
        .token-p1-4 .counter-value { color: #95e1d3; }
        
        .token-p2-1 { border-color: #ff9a76; }
        .token-p2-1 .counter-value { color: #ff9a76; }
        
        .token-p2-2 { border-color: #a8e6cf; }
        .token-p2-2 .counter-value { color: #a8e6cf; }
        
        .token-p2-3 { border-color: #ffd3b6; }
        .token-p2-3 .counter-value { color: #ffd3b6; }
        
        .token-p2-4 { border-color: #a8d8ea; }
        .token-p2-4 .counter-value { color: #a8d8ea; }
        
        .quantity-selector {
            background: #222;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            min-width: 300px;
        }
        
        .quantity-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }
        
        .qty-btn {
            width: 40px;
            height: 40px;
            font-size: 20px;
            background: #444;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            color: white;
        }
        
        .qty-btn:hover {
            background: #666;
        }
        
        .qty-display {
            font-size: 24px;
            font-weight: bold;
            min-width: 50px;
        }
        
        .quantity-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        #deckOverlayContent { 
            background: #222; 
            padding: 20px; 
            border-radius: 8px; 
            max-width: 90%; 
            max-height: 90%; 
            overflow: auto; 
        }
        #deckCardsContainer { 
            display: grid; 
            grid-template-columns: repeat(5, 1fr);
            grid-auto-rows: min-content;
            gap: 10px; 
            margin-top: 20px; 
        }
        
        .deck-card {
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .deck-card:hover {
            transform: scale(1.05);
        }
        
        .deck-card-row {
            display: contents;
        }
        
        .deck-card:nth-child(5n+1) { grid-column: 1; }
        .deck-card:nth-child(5n+2) { grid-column: 2; }
        .deck-card:nth-child(5n+3) { grid-column: 3; }
        .deck-card:nth-child(5n+4) { grid-column: 4; }
        .deck-card:nth-child(5n+5) { grid-column: 5; }
        
        .life-zones-container {
            position: absolute;
            top: 10px;
            right: 160px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }

        .life-zone {
            width: 100px;
            height: 40px;
            border: 2px dashed #7ED321;
            border-radius: 6px;
            background: rgba(126, 211, 33, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .life-zone:hover {
            border-color: #9fea5f;
            background: rgba(126, 211, 33, 0.2);
        }

        .life-zone.has-card {
            border-style: solid;
            border-color: #7ED321;
            background: rgba(126, 211, 33, 0.3);
        }

        .life-zone-card {
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            border-radius: 4px;
            position: relative;
        }
        
        .life-zone-card.flipped {
            transform: rotateY(180deg);
            background: linear-gradient(45deg, #333, #666);
        }
        
        .life-zone-card.flipped::after {
            content: "FACEDOWN";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotateY(180deg);
            color: white;
            font-weight: bold;
            font-size: 8px;
            text-align: center;
        }

        .life-zone-number {
            position: absolute;
            top: 2px;
            left: 2px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 10px;
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: bold;
        }

        .life-zone-label {
            font-size: 11px;
            color: #7ED321;
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
        }

        .life-shuffle-btn {
            background: #7ED321;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            margin-top: 5px;
            width: 100%;
        }

        .life-shuffle-btn:hover {
            background: #9fea5f;
        }
        
        .life-zone-flip-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            background: rgba(0, 204, 255, 0.9);
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .life-zone.has-card:hover .life-zone-flip-btn {
            opacity: 1;
        }
        
        .life-zone-flip-btn:hover {
            background: rgba(0, 204, 255, 1);
            transform: scale(1.1);
        }
        
        .add-to-life-btn {
            background: #7ED321;
            color: white;
            border: 1px solid #9fea5f;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-weight: bold;
            margin: 2px;
        }
        
        .add-to-life-btn:hover {
            background: #9fea5f;
        }
        
        .shuffle-animation {
            position: fixed;
            width: 120px;
            height: 180px;
            border-radius: 6px;
            background: linear-gradient(145deg, #2c2c2c, #1a1a1a);
            border: 2px solid #444;
            z-index: 99999;
            pointer-events: none;
            animation: shuffleCard 0.8s ease-out;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .shuffle-animation::before {
            content: '';
            position: absolute;
            width: 100px;
            height: 150px;
            background: linear-gradient(135deg, #333 0%, #555 50%, #333 100%);
            border-radius: 4px;
            border: 2px solid #666;
        }
        
        .shuffle-animation::after {
            content: 'SHUFFLE';
            position: absolute;
            color: #aaa;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
        
        @keyframes shuffleCard {
            0% {
                transform: translate(var(--start-x), var(--start-y)) scale(1) rotate(0deg);
                opacity: 1;
            }
            30% {
                transform: translate(calc(var(--start-x) + 50px), calc(var(--start-y) - 100px)) scale(1.1) rotate(180deg);
                opacity: 0.8;
            }
            60% {
                transform: translate(calc(var(--start-x) - 50px), calc(var(--start-y) + 100px)) scale(1.2) rotate(360deg);
                opacity: 0.6;
            }
            100% {
                transform: translate(var(--start-x), var(--start-y)) scale(1) rotate(720deg);
                opacity: 0;
            }
        }

        .multiplayer-btn {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            z-index: 200;
            background: linear-gradient(145deg, #2196F3, #1976D2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
            transition: all 0.3s;
        }
        
        .multiplayer-btn:hover {
            background: linear-gradient(145deg, #1976D2, #1565C0);
            transform: translateY(-50%) scale(1.05);
        }
        
        .multiplayer-overlay {
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
        }
        
        .multiplayer-panel {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            border: 2px solid #2196F3;
            box-shadow: 0 0 30px rgba(33, 150, 243, 0.2);
        }
        
        .game-code {
            font-family: monospace;
            font-size: 32px;
            letter-spacing: 3px;
            background: #333;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            color: #4CAF50;
            text-align: center;
            border: 2px solid #4CAF50;
        }
        
        .copy-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        
        .player-status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .player-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            margin: 5px;
            font-weight: bold;
        }
        
        .player1-badge {
            background: rgba(68, 136, 255, 0.2);
            border: 2px solid #4488ff;
            color: #4488ff;
        }
        
        .player2-badge {
            background: rgba(136, 68, 255, 0.2);
            border: 2px solid #8844ff;
            color: #8844ff;
        }
        
        .chat-box {
            margin-top: 20px;
            border-top: 1px solid #444;
            padding-top: 20px;
        }
        
        .chat-messages {
            height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
        }
        
        .chat-input {
            width: 100%;
            padding: 10px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 5px;
        }
    </style>
</head>
<body>

<!-- NOTIFICATION CONTAINER -->
<div class="notification-container" id="notificationContainer"></div>

<!-- MULTIPLAYER OVERLAY -->
<div id="multiplayerOverlay" class="overlay multiplayer-overlay" style="display: none;">
    <div class="multiplayer-panel">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h2 style="color: #2196F3; margin: 0;">üåê Online Multiplayer</h2>
            <button onclick="closeMultiplayerMenu()" style="background:#c00; padding: 8px 16px;">Close</button>
        </div>
        
        <div id="createGameSection">
            <h3>üéÆ Host New Game</h3>
            <p>Create a game room and invite your friend</p>
            <button onclick="createGame()" style="background: #4CAF50; padding: 15px 30px; font-size: 18px; margin: 15px 0; width: 100%;">
                üöÄ Create Game Room
            </button>
        </div>
        
        <div id="joinGameSection" style="margin-top: 30px;">
            <h3>üîó Join Game</h3>
            <p>Enter the game code from your friend:</p>
            <input type="text" id="gameCodeInput" placeholder="Enter 6-digit code" 
                   style="padding: 15px; width: 100%; font-size: 18px; margin: 10px 0; text-align: center; letter-spacing: 3px;"
                   maxlength="6" oninput="this.value = this.value.toUpperCase()">
            <button onclick="joinGame()" style="background: #2196F3; padding: 15px 30px; width: 100%; font-size: 16px;">
                ‚úÖ Join Game
            </button>
        </div>
        
        <div id="gameInfoSection" style="display: none;">
            <h3>üéÆ Game Room</h3>
            <p>Share this code with your friend:</p>
            <div class="game-code" id="displayGameCode">XXXXXX</div>
            
            <div style="display: flex; gap: 10px; justify-content: center; margin: 15px 0;">
                <button class="copy-btn" onclick="copyGameCode()">
                    üìã Copy Code
                </button>
                <button class="copy-btn" onclick="copyGameLink()" style="background: #2196F3;">
                    üîó Copy Invite Link
                </button>
            </div>
            
            <div class="player-status">
                <h4>üë• Players</h4>
                <div id="playerList">
                    <div class="player-badge player1-badge">Player 1 (You) ‚úÖ</div>
                    <div class="player-badge player2-badge">Player 2 (Waiting...)</div>
                </div>
            </div>
            
            <div class="chat-box">
                <h4>üí¨ Chat</h4>
                <div class="chat-messages" id="chatMessages">
                    <div style="color: #888; font-style: italic;">Chat messages will appear here...</div>
                </div>
                <div style="display: flex; gap: 10px;">
                    <input type="text" class="chat-input" id="chatInput" placeholder="Type message..." 
                           onkeypress="if(event.key === 'Enter') sendChatMessage()">
                    <button onclick="sendChatMessage()" style="background: #666; padding: 10px 20px;">Send</button>
                </div>
            </div>
            
            <button onclick="leaveGame()" style="background: #f44336; padding: 12px 24px; width: 100%; margin-top: 20px;">
                üö™ Leave Game
            </button>
        </div>
    </div>
</div>

<div id="board">
    <!-- MULTIPLAYER BUTTON -->
    <button class="multiplayer-btn" onclick="showMultiplayerMenu()" id="multiplayerButton">
        üåê Online Play
    </button>

    <!-- PLAYER 2 AREA -->
    <div class="player-area" id="player2Area">
        <!-- DECK CONTAINER -->
        <div class="deck-container">
            <div class="deck-label">Deck P2</div>
            <div id="deck2" class="deck-zone" onclick="viewDeck(2)">
                <div class="deck-visual">
                    <div class="deck-card-stack"></div>
                    <span class="deck-count" id="deckCount2">0</span>
                </div>
            </div>
            <button class="deck-shuffle-btn" id="shuffleBtn2" onclick="shuffleDeckWithAnimation(2)" disabled>üîÄ Shuffle Deck</button>
            <button class="open-btn" id="openBtn2" onclick="openFromDeck(2)" disabled>Open from Deck</button>
        </div>
        
        <!-- PLAYER 2 CONTROLS -->
        <div id="p2Controls" class="controls">
            <strong>P2</strong> | Hand: <span id="handCount2">0</span>
            <button onclick="drawCardWithAnimation(2)">Draw</button>
            <button onclick="viewHand(2)">View Hand</button>
        </div>
        
        <!-- PLAYER 2 TOKEN CONTROLS -->
        <div class="token-controls-top">
            <div class="token-controls-label">P2 Tokens</div>
            <button class="small-token-btn" onclick="addTokenToPlayer(2)">Token</button>
            <button class="small-token-reset-btn" onclick="resetPlayerTokens(2)">Reset</button>
        </div>
        
        <!-- LIFE ZONES -->
        <div class="life-zones-container">
            <div class="life-zone-label">Life Zones</div>
            <div id="lifeZones2" class="life-zones"></div>
            <button class="life-shuffle-btn" onclick="shuffleLifeZones(2)">üîÄ Shuffle Life Zones</button>
        </div>
        
        <!-- GRAVEYARD ZONE -->
        <div id="gy2" class="graveyard" onclick="viewGraveyard(2)">
            <span>Graveyard P2</span>
            <span class="graveyard-count" id="gyCount2">0</span>
        </div>
    </div>

    <!-- PLAYER 1 AREA -->
    <div class="player-area" id="player1Area">
        <!-- DECK CONTAINER -->
        <div class="deck-container">
            <div class="deck-label">Deck P1</div>
            <div id="deck1" class="deck-zone" onclick="viewDeck(1)">
                <div class="deck-visual">
                    <div class="deck-card-stack"></div>
                    <span class="deck-count" id="deckCount1">0</span>
                </div>
            </div>
            <button class="deck-shuffle-btn" id="shuffleBtn1" onclick="shuffleDeckWithAnimation(1)" disabled>üîÄ Shuffle Deck</button>
            <button class="open-btn" id="openBtn1" onclick="openFromDeck(1)" disabled>Open from Deck</button>
        </div>
        
        <!-- PLAYER 1 CONTROLS -->
        <div id="p1Controls" class="controls">
            <strong>P1</strong> | Hand: <span id="handCount1">0</span>
            <button onclick="drawCardWithAnimation(1)">Draw</button>
            <button onclick="viewHand(1)">View Hand</button>
        </div>
        
        <!-- PLAYER 1 TOKEN CONTROLS -->
        <div class="token-controls">
            <div class="token-controls-label">P1 Tokens</div>
            <button class="small-token-btn" onclick="addTokenToPlayer(1)">Token</button>
            <button class="small-token-reset-btn" onclick="resetPlayerTokens(1)">Reset</button>
        </div>
        
        <!-- LIFE ZONES -->
        <div class="life-zones-container">
            <div class="life-zone-label">Life Zones</div>
            <div id="lifeZones1" class="life-zones"></div>
            <button class="life-shuffle-btn" onclick="shuffleLifeZones(1)">üîÄ Shuffle Life Zones</button>
        </div>
        
        <!-- GRAVEYARD ZONE -->
        <div id="gy1" class="graveyard" onclick="viewGraveyard(1)">
            <span>Graveyard P1</span>
            <span class="graveyard-count" id="gyCount1">0</span>
        </div>
    </div>

    <button id="shopButton" onclick="openShop()">üõçÔ∏è Shop</button>
</div>

<!-- SHOP OVERLAY -->
<div id="shopOverlay" class="overlay" style="align-items: stretch;">
    <div id="shopWindow">
        <div style="display:flex; justify-content:space-between;">
            <h2>Card Shop</h2> 
            <button onclick="closeShop()" style="background:#c00">Close</button>
        </div>
        
        <!-- CATEGORY BUTTONS -->
        <div class="category-buttons">
            <button class="category-btn active" onclick="filterShopCards('all', event)">All Cards</button>
            <button class="category-btn" onclick="filterShopCards('avatar', event)">Avatar</button>
            <button class="category-btn" onclick="filterShopCards('magic', event)">Magic</button>
            <button class="category-btn" onclick="filterShopCards('construct', event)">Construct</button>
            <button class="category-btn" onclick="filterShopCards('life', event)">Life</button>
        </div>
        
        <!-- SPECIAL BUTTONS FOR LIFE CATEGORY -->
        <div id="lifeCategoryButtons" style="display: none; gap: 10px; margin-bottom: 15px;">
            <button class="add-to-life-btn" onclick="addToLifeZone(1)">Add to P1 Life Zone</button>
            <button class="add-to-life-btn" onclick="addToLifeZone(2)">Add to P2 Life Zone</button>
        </div>
        
        <div id="shopCards"></div>
    </div>
</div>

<!-- QUANTITY SELECTOR OVERLAY -->
<div id="quantityOverlay" class="overlay">
    <div class="quantity-selector">
        <h3>Add Cards to Deck</h3>
        <div id="quantityCardPreview" style="width: 120px; height: 180px; margin: 0 auto 20px; background-size: cover; border-radius: 6px;"></div>
        <p>How many copies do you want to add?</p>
        
        <div class="quantity-controls">
            <button class="qty-btn" onclick="changeQuantity(-1)">-</button>
            <div class="qty-display" id="quantityDisplay">1</div>
            <button class="qty-btn" onclick="changeQuantity(1)">+</button>
        </div>
        
        <div class="quantity-actions">
            <button id="addToP1DeckQty" style="background:#448;">Add to P1 Deck</button>
            <button id="addToP2DeckQty" style="background:#844;">Add to P2 Deck</button>
            <button onclick="closeQuantitySelector()" style="background:#c00">Cancel</button>
        </div>
    </div>
</div>

<!-- ZOOM OVERLAY -->
<div id="zoomOverlay" class="overlay">
    <div id="zoomCard"></div>
    <div style="display:flex; gap:10px; flex-wrap: wrap; justify-content: center;">
        <button id="addToDeckP1" style="background:#448;">Add to P1 Deck</button>
        <button id="addToDeckP2" style="background:#844;">Add to P2 Deck</button>
        <button id="playToBoard" style="background:#282;">Play</button>
        <button id="moveToHand" style="background:#448;">Put to Hand</button>
        <button id="moveToDeck" style="background:#844;">Put to Deck</button>
        <button id="moveToGY" style="background:#282;">Send to GY</button>
        <button id="putToBoardFromGY" style="background:#8B4513; display:none;">Put to Board</button>
        <button id="putToBoardFromDeck" style="background:#008080; display:none;">Put to Board</button>
        <button id="rotateCardBtn" style="background:#ff9900; display:none;" onclick="rotateCard()">Rotate</button>
        <button id="removeFromLifeZone" style="background:#d35400; display:none;" onclick="removeFromLifeZone()">Remove from Life Zone</button>
        <button id="flipLifeZoneCard" style="background:#00ccff; display:none;" onclick="flipLifeZoneCard()">Flip Card</button>
        <button id="deleteCardBtn" style="background:#ff4444; display:none;" onclick="showDeleteConfirmation()">Delete</button>
        <button onclick="closeZoomOnly()">Close</button>
    </div>
</div>

<!-- CONFIRM DELETE OVERLAY -->
<div id="confirmDeleteOverlay" class="confirm-delete-overlay">
    <div class="confirm-delete-box">
        <h3>‚ö†Ô∏è Delete Card</h3>
        <p>Are you sure you want to delete this card?</p>
        <p><strong>This action cannot be undone!</strong></p>
        <p>The card will be permanently removed from the board.</p>
        
        <div class="confirm-delete-actions">
            <button class="confirm-delete-btn" onclick="confirmDeleteCard()">Yes, Delete</button>
            <button class="cancel-delete-btn" onclick="cancelDeleteCard()">Cancel</button>
        </div>
    </div>
</div>

<!-- HAND OVERLAY -->
<div id="handOverlay" class="overlay">
    <div id="handOverlayContent">
        <h2 id="handTitle">Cards</h2>
        <div id="handCardsContainer"></div>
        <button onclick="closeHand()">Close</button>
    </div>
</div>

<!-- DECK OVERLAY -->
<div id="deckOverlay" class="overlay">
    <div id="deckOverlayContent">
        <h2 id="deckTitle">Deck</h2>
        <div id="deckCardsContainer"></div>
        <button onclick="closeDeck()">Close</button>
    </div>
</div>

<!-- GRAVEYARD OVERLAY -->
<div id="graveyardOverlay" class="overlay">
    <div id="graveyardOverlayContent" style="background: #222; padding: 20px; border-radius: 8px; max-width: 90%; max-height: 90%; overflow: auto;">
        <h2 id="graveyardTitle">Graveyard</h2>
        <div id="graveyardCardsContainer" style="display: grid; grid-template-columns: repeat(auto-fill, 120px); gap: 15px; margin-top: 20px;"></div>
        <button onclick="closeGraveyard()">Close</button>
    </div>
</div>

<script>
// ============================================================================
// FIREBASE CONFIGURATION
// ============================================================================
const firebaseConfig = {
  apiKey: "AIzaSyCWJUqRC00L1h7W8BgDmP8UjVHXbyaJaas",
  authDomain: "boardgame2-95da5.firebaseapp.com",
  databaseURL: "https://boardgame2-95da5-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "boardgame2-95da5",
  storageBucket: "boardgame2-95da5.firebasestorage.app",
  messagingSenderId: "196618431674",
  appId: "1:196618431674:web:fc4898cb08f60420b26683"
};

// Initialize Firebase
let database;
try {
  firebase.initializeApp(firebaseConfig);
  database = firebase.database();
  console.log("‚úÖ Firebase initialized successfully!");
} catch (error) {
  console.error("‚ùå Firebase error:", error);
}

// ============================================================================
// NOTIFICATION SYSTEM
// ============================================================================
function showNotification(title, message, type = 'info', duration = 3000) {
    const container = document.getElementById('notificationContainer');
    if (!container) return;
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    
    const icon = type === 'success' ? '‚úì' : 
                 type === 'warning' ? '‚ö†' : 
                 type === 'error' ? '‚úó' : 
                 '‚Ñπ';
    
    notification.innerHTML = `
        <button class="notification-close" onclick="this.parentElement.classList.add('fade-out')">√ó</button>
        <div class="notification-title">${icon} ${title}</div>
        <div class="notification-message">${message}</div>
    `;
    
    container.appendChild(notification);
    
    if (duration > 0) {
        setTimeout(() => {
            notification.classList.add('fade-out');
            setTimeout(() => notification.remove(), 300);
        }, duration);
    }
}

// ============================================================================
// MULTIPLAYER STATE - REAL-TIME SYNC
// ============================================================================
let multiplayer = {
    gameId: null,
    playerId: null,
    playerNumber: null,
    opponentNumber: null,
    isHost: false,
    gameRef: null,
    boardStateRef: null,
    lastSyncTime: 0,
    isSyncing: false
};

// ============================================================================
// GAME STATE
// ============================================================================
let decks = { 1: [], 2: [] };
let hands = { 1: [], 2: [] };
let graveyards = { 1: [], 2: [] };
let boardCards = [];
let counterTokens = { 1: [], 2: [] };
let lifeZones = { 1: Array(5).fill(null), 2: Array(5).fill(null) };
let currentZoomImage = "";
let currentZoomSource = null;
let cardToDelete = null;

let dragState = {
    isDragging: false,
    card: null,
    originalCard: null,
    originalParent: null,
    originalLeft: 0,
    originalTop: 0,
    ghostCard: null,
    startX: 0,
    startY: 0,
    mouseDownTime: 0,
    clickThreshold: 200,
    lastDraggedCard: null,
    draggingToken: false
};

let quantitySelectorState = {
    image: "",
    category: "",
    quantity: 1
};

let currentShopCategory = 'all';
let currentShopImage = null;

const CARD_CATEGORIES = {
    avatar: {
        name: "Avatar",
        folder: "Taling/Avatar/",
        prefix: "avatar",
        count: 484,
        color: "#4A90E2"
    },
    magic: {
        name: "Magic",
        folder: "Taling/Magic/",
        prefix: "magic",
        count: 219,
        color: "#9013FE"
    },
    construct: {
        name: "Construct",
        folder: "Taling/Construct/",
        prefix: "con",
        count: 18,
        color: "#F5A623"
    },
    life: {
        name: "Life",
        folder: "Taling/Life/",
        prefix: "life",
        count: 48,
        color: "#7ED321"
    }
};

const TOKEN_COLORS = {
    1: ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3'],
    2: ['#ff9a76', '#a8e6cf', '#ffd3b6', '#a8d8ea']
};

const TOKEN_LABELS = ['Health', 'Mana', 'Attack', 'Defense'];

const IMAGE_EXT = ".png";
let allShopCards = [];

// ============================================================================
// MULTIPLAYER FUNCTIONS
// ============================================================================
function showMultiplayerMenu() {
    document.getElementById('multiplayerOverlay').style.display = 'flex';
}

function closeMultiplayerMenu() {
    document.getElementById('multiplayerOverlay').style.display = 'none';
}

function createGame() {
    if (!database) {
        showNotification("Firebase Error", "Database not initialized", "error");
        return;
    }
    
    multiplayer.playerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    multiplayer.playerNumber = 1;
    multiplayer.opponentNumber = 2;
    multiplayer.isHost = true;
    
    multiplayer.gameId = generateGameCode();
    
    document.getElementById('createGameSection').style.display = 'none';
    document.getElementById('joinGameSection').style.display = 'none';
    document.getElementById('gameInfoSection').style.display = 'block';
    document.getElementById('displayGameCode').textContent = multiplayer.gameId;
    
    multiplayer.gameRef = database.ref('games/' + multiplayer.gameId);
    multiplayer.boardStateRef = database.ref('boardStates/' + multiplayer.gameId);
    
    const initialGameState = getGameStateForSync();
    
    multiplayer.gameRef.set({
        hostId: multiplayer.playerId,
        players: {
            [multiplayer.playerId]: {
                playerNumber: 1,
                name: "Player 1",
                connected: true,
                lastSeen: Date.now()
            }
        },
        chat: [],
        createdAt: Date.now(),
        status: 'waiting'
    }).then(() => {
        multiplayer.boardStateRef.set(initialGameState);
        
        multiplayer.gameRef.on('value', handleGameUpdate);
        multiplayer.boardStateRef.on('value', handleBoardStateUpdate);
        
        showNotification('Game Created!', `Share code: ${multiplayer.gameId}`, 'success');
        
        const multiplayerBtn = document.getElementById('multiplayerButton');
        multiplayerBtn.textContent = 'üåê Room: ' + multiplayer.gameId;
        multiplayerBtn.style.background = 'linear-gradient(145deg, #4CAF50, #388E3C)';
    });
}

function joinGame() {
    const code = document.getElementById('gameCodeInput').value.trim().toUpperCase();
    if (!code || code.length !== 6) {
        showNotification('Invalid Code', 'Please enter a 6-digit code', 'error');
        return;
    }
    
    if (!database) {
        showNotification("Firebase Error", "Database not initialized", "error");
        return;
    }
    
    multiplayer.playerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    multiplayer.playerNumber = 2;
    multiplayer.opponentNumber = 1;
    multiplayer.isHost = false;
    multiplayer.gameId = code;
    
    multiplayer.gameRef = database.ref('games/' + code);
    multiplayer.boardStateRef = database.ref('boardStates/' + code);
    
    multiplayer.gameRef.once('value').then((snapshot) => {
        if (!snapshot.exists()) {
            showNotification('Game Not Found', 'Check the code and try again', 'error');
            return;
        }
        
        const gameData = snapshot.val();
        const players = gameData.players || {};
        const playerCount = Object.keys(players).length;
        
        if (playerCount >= 2) {
            showNotification('Game Full', 'This game already has 2 players', 'error');
            return;
        }
        
        return multiplayer.gameRef.update({
            [`players/${multiplayer.playerId}`]: {
                playerNumber: 2,
                name: "Player 2",
                connected: true,
                lastSeen: Date.now()
            },
            lastUpdate: Date.now(),
            status: 'playing'
        });
    }).then(() => {
        document.getElementById('createGameSection').style.display = 'none';
        document.getElementById('joinGameSection').style.display = 'none';
        document.getElementById('gameInfoSection').style.display = 'block';
        document.getElementById('displayGameCode').textContent = code;
        
        multiplayer.gameRef.on('value', handleGameUpdate);
        multiplayer.boardStateRef.on('value', handleBoardStateUpdate);
        
        showNotification('Joined Game!', 'Connected to host', 'success');
        
        const multiplayerBtn = document.getElementById('multiplayerButton');
        multiplayerBtn.textContent = 'üåê Room: ' + multiplayer.gameId;
        multiplayerBtn.style.background = 'linear-gradient(145deg, #2196F3, #1976D2)';
        
        multiplayer.boardStateRef.once('value').then((snapshot) => {
            if (snapshot.exists()) {
                syncGameStateFromFirebase(snapshot.val());
            }
        });
    });
}

function handleGameUpdate(snapshot) {
    if (!snapshot.exists()) {
        if (multiplayer.gameId) {
            showNotification('Game Ended', 'Host left the game', 'warning');
            leaveGame();
        }
        return;
    }
    
    const gameData = snapshot.val();
    
    const playerList = document.getElementById('playerList');
    if (playerList) {
        playerList.innerHTML = '';
        Object.entries(gameData.players || {}).forEach(([playerId, player]) => {
            const badgeClass = player.playerNumber === 1 ? 'player1-badge' : 'player2-badge';
            const youText = player.playerNumber === multiplayer.playerNumber ? ' (You)' : '';
            playerList.innerHTML += `<div class="player-badge ${badgeClass}">Player ${player.playerNumber}${youText} ‚úÖ</div>`;
        });
    }
    
    if (gameData.chat) {
        const chatContainer = document.getElementById('chatMessages');
        if (chatContainer) {
            chatContainer.innerHTML = '';
            Object.values(gameData.chat).forEach(msg => {
                const msgDiv = document.createElement('div');
                msgDiv.innerHTML = `<strong>Player ${msg.sender}:</strong> ${msg.text}`;
                msgDiv.style.margin = '5px 0';
                msgDiv.style.padding = '8px';
                msgDiv.style.background = msg.sender === multiplayer.playerNumber ? 'rgba(33, 150, 243, 0.2)' : 'rgba(255, 255, 255, 0.1)';
                msgDiv.style.borderRadius = '10px';
                chatContainer.appendChild(msgDiv);
            });
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
    }
}

function handleBoardStateUpdate(snapshot) {
    if (!snapshot.exists() || !multiplayer.gameId || multiplayer.isSyncing) return;
    
    const boardState = snapshot.val();
    
    if (boardState.lastUpdatePlayer === multiplayer.playerNumber) {
        return;
    }
    
    if (boardState.timestamp > multiplayer.lastSyncTime) {
        multiplayer.lastSyncTime = boardState.timestamp;
        syncGameStateFromFirebase(boardState);
        
        if (boardState.lastUpdatePlayer && boardState.lastUpdatePlayer !== multiplayer.playerNumber) {
            showNotification(`Player ${boardState.lastUpdatePlayer}`, 'Updated the board', 'info', 2000);
        }
    }
}

function sendChatMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    
    if (!message || !multiplayer.gameRef) return;
    
    const chatMessage = {
        sender: multiplayer.playerNumber,
        text: message,
        timestamp: Date.now()
    };
    
    multiplayer.gameRef.child('chat').push(chatMessage);
    input.value = '';
}

function copyGameCode() {
    if (!multiplayer.gameId) return;
    navigator.clipboard.writeText(multiplayer.gameId);
    showNotification('Copied!', 'Game code copied', 'success');
}

function copyGameLink() {
    if (!multiplayer.gameId) return;
    const link = window.location.href.split('?')[0] + '?game=' + multiplayer.gameId;
    navigator.clipboard.writeText(link);
    showNotification('Copied!', 'Invite link copied', 'success');
}

function leaveGame() {
    if (multiplayer.gameRef) {
        multiplayer.gameRef.child('players/' + multiplayer.playerId).remove();
        multiplayer.gameRef.off();
        multiplayer.boardStateRef.off();
    }
    
    multiplayer = {
        gameId: null,
        playerId: null,
        playerNumber: null,
        opponentNumber: null,
        isHost: false,
        gameRef: null,
        boardStateRef: null,
        lastSyncTime: 0,
        isSyncing: false
    };
    
    document.getElementById('createGameSection').style.display = 'block';
    document.getElementById('joinGameSection').style.display = 'block';
    document.getElementById('gameInfoSection').style.display = 'none';
    
    const multiplayerBtn = document.getElementById('multiplayerButton');
    multiplayerBtn.textContent = 'üåê Online Play';
    multiplayerBtn.style.background = 'linear-gradient(145deg, #2196F3, #1976D2)';
    
    showNotification('Left Game', 'You have left the game', 'info');
}

function generateGameCode() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let result = '';
    for (let i = 0; i < 6; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
}

// ============================================================================
// SYNC FUNCTIONS
// ============================================================================
function getGameStateForSync() {
    const boardCardsData = boardCards.map(card => ({
        id: card.id,
        image: card.image,
        player: card.player,
        x: parseFloat(card.element?.style.left) || 0,
        y: parseFloat(card.element?.style.top) || 0,
        rotated: card.rotated || false,
        color: card.color
    }));
    
    const tokensData = {};
    Object.keys(counterTokens).forEach(player => {
        tokensData[player] = counterTokens[player].map(token => ({
            id: token.id,
            value: token.value || 0,
            label: token.label || 'Token',
            color: token.color,
            x: token.position?.x || 0,
            y: token.position?.y || 0
        }));
    });
    
    return {
        decks: JSON.parse(JSON.stringify(decks)),
        hands: JSON.parse(JSON.stringify(hands)),
        graveyards: JSON.parse(JSON.stringify(graveyards)),
        boardCards: boardCardsData,
        counterTokens: tokensData,
        lifeZones: JSON.parse(JSON.stringify(lifeZones)),
        timestamp: Date.now(),
        lastUpdatePlayer: multiplayer.playerNumber
    };
}

function syncGameStateToFirebase() {
    if (!multiplayer.boardStateRef || multiplayer.isSyncing) return;
    
    multiplayer.isSyncing = true;
    
    try {
        const gameState = getGameStateForSync();
        multiplayer.boardStateRef.set(gameState)
            .then(() => {
                console.log("‚úÖ Game state synced to Firebase");
            })
            .catch(error => {
                console.error("‚ùå Sync error:", error);
            })
            .finally(() => {
                multiplayer.isSyncing = false;
            });
    } catch (error) {
        console.error("‚ùå Error getting game state:", error);
        multiplayer.isSyncing = false;
    }
}

function syncGameStateFromFirebase(firebaseState) {
    if (multiplayer.isSyncing) return;
    
    multiplayer.isSyncing = true;
    
    try {
        const ourPlayer = multiplayer.playerNumber;
        
        document.querySelectorAll('.board-card').forEach(el => {
            const cardId = el.id;
            const card = boardCards.find(c => c.id === cardId);
            if (card && card.player !== ourPlayer) {
                el.remove();
            }
        });
        
        document.querySelectorAll('.counter-token').forEach(el => {
            const tokenId = el.id;
            let found = false;
            for (const player of [1, 2]) {
                const token = counterTokens[player].find(t => t.id === tokenId);
                if (token && token.player === ourPlayer) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                el.remove();
            }
        });
        
        boardCards = boardCards.filter(card => card.player === ourPlayer);
        
        Object.keys(counterTokens).forEach(player => {
            counterTokens[player] = counterTokens[player].filter(token => token.player === ourPlayer);
        });
        
        if (firebaseState.decks) {
            decks = JSON.parse(JSON.stringify(firebaseState.decks));
            updateDeckVisual(1);
            updateDeckVisual(2);
        }
        
        if (firebaseState.hands) {
            hands = JSON.parse(JSON.stringify(firebaseState.hands));
        }
        
        if (firebaseState.graveyards) {
            graveyards = JSON.parse(JSON.stringify(firebaseState.graveyards));
        }
        
        if (firebaseState.boardCards) {
            firebaseState.boardCards.forEach(cardData => {
                if (cardData.player === ourPlayer) return;
                
                const cardId = cardData.id;
                const player = cardData.player;
                
                if (!document.getElementById(cardId)) {
                    const playerArea = document.getElementById(`player${player}Area`);
                    if (!playerArea) return;
                    
                    const cardElement = document.createElement("div");
                    cardElement.className = "board-card";
                    cardElement.id = cardId;
                    cardElement.style.backgroundImage = `url('${cardData.image}')`;
                    cardElement.style.left = `${cardData.x}px`;
                    cardElement.style.top = `${cardData.y}px`;
                    cardElement.style.borderColor = cardData.color || "#555";
                    cardElement.style.borderWidth = "3px";
                    
                    if (cardData.rotated) {
                        cardElement.classList.add('rotated');
                    }
                    
                    cardElement.style.cursor = 'default';
                    cardElement.title = "Opponent's card";
                    
                    cardElement.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showCardZoom(cardData.image, { 
                            type: 'board', 
                            player: player, 
                            cardId: cardId,
                            isOpponent: true 
                        });
                    });
                    
                    playerArea.appendChild(cardElement);
                    
                    boardCards.push({
                        id: cardId,
                        image: cardData.image,
                        player: player,
                        element: cardElement,
                        color: cardData.color,
                        rotated: cardData.rotated || false,
                        isOpponent: true
                    });
                }
            });
        }
        
        if (firebaseState.counterTokens) {
            Object.keys(firebaseState.counterTokens).forEach(player => {
                const playerNum = parseInt(player);
                if (playerNum === ourPlayer) return;
                
                firebaseState.counterTokens[player].forEach(tokenData => {
                    const tokenId = tokenData.id;
                    
                    if (!document.getElementById(tokenId)) {
                        const playerArea = document.getElementById(`player${playerNum}Area`);
                        if (!playerArea) return;
                        
                        const tokenIndex = counterTokens[playerNum].length;
                        const tokenColor = TOKEN_COLORS[playerNum][tokenIndex % 4];
                        
                        const token = document.createElement("div");
                        token.className = `counter-token token-p${playerNum}-${(tokenIndex % 4) + 1}`;
                        token.id = tokenId;
                        token.style.left = `${tokenData.x || 0}px`;
                        token.style.top = `${tokenData.y || 0}px`;
                        token.style.cursor = 'default';
                        token.title = "Opponent's token";
                        
                        token.innerHTML = `
                            <div class="counter-value">${tokenData.value || 0}</div>
                            <div class="counter-label">${tokenData.label || 'Token'}</div>
                        `;
                        
                        playerArea.appendChild(token);
                        
                        counterTokens[playerNum].push({
                            id: tokenId,
                            player: playerNum,
                            value: tokenData.value || 0,
                            label: tokenData.label || 'Token',
                            color: tokenColor,
                            element: token,
                            position: { x: tokenData.x || 0, y: tokenData.y || 0 },
                            isOpponent: true
                        });
                    }
                });
            });
        }
        
        if (firebaseState.lifeZones) {
            lifeZones = JSON.parse(JSON.stringify(firebaseState.lifeZones));
            for (let player of [1, 2]) {
                for (let i = 0; i < 5; i++) {
                    updateLifeZoneDisplay(player, i, lifeZones[player][i], player !== ourPlayer);
                }
            }
        }
        
        updateCounters();
        
    } catch (error) {
        console.error("‚ùå Error loading game state:", error);
    } finally {
        multiplayer.isSyncing = false;
    }
}

// ============================================================================
// AUTO-SYNC WRAPPER
// ============================================================================
function autoSync(originalFunction) {
    return function(...args) {
        const result = originalFunction.apply(this, args);
        
        if (multiplayer.gameId) {
            setTimeout(() => {
                syncGameStateToFirebase();
            }, 100);
        }
        
        return result;
    };
}

// ============================================================================
// CORE GAME FUNCTIONS
// ============================================================================
function updateDeckVisual(player) {
    const deckZone = document.getElementById(`deck${player}`);
    const deckCount = decks[player].length;
    const deckStack = deckZone.querySelector('.deck-card-stack');
    
    document.getElementById(`deckCount${player}`).textContent = deckCount;
    
    if (deckCount === 0) {
        deckZone.classList.add('empty');
        document.getElementById(`shuffleBtn${player}`).disabled = true;
        document.getElementById(`openBtn${player}`).disabled = true;
    } else {
        deckZone.classList.remove('empty');
        document.getElementById(`shuffleBtn${player}`).disabled = false;
        document.getElementById(`openBtn${player}`).disabled = false;
        
        deckStack.innerHTML = '';
        const layers = Math.min(5, deckCount);
        for (let i = 0; i < layers; i++) {
            const layer = document.createElement('div');
            layer.className = 'deck-card-layer';
            deckStack.appendChild(layer);
        }
    }
}
updateDeckVisual = autoSync(updateDeckVisual);

function drawCardWithAnimation(player) {
    if (decks[player].length === 0) {
        showNotification("Deck Empty", "Open Shop to add cards to your deck!", 'warning');
        return;
    }
    
    const cardData = decks[player].shift();
    hands[player].push(cardData);
    updateCounters();
    updateDeckVisual(player);
    
    showNotification("Card Drawn", `Player ${player} drew 1 card`, 'success');
}
drawCardWithAnimation = autoSync(drawCardWithAnimation);

function shuffleDeckWithAnimation(player) {
    if (decks[player].length === 0) {
        showNotification("Deck Empty", "No cards to shuffle!", 'warning');
        return;
    }
    
    decks[player].sort(() => Math.random() - 0.5);
    updateDeckVisual(player);
    
    showNotification("Deck Shuffled", `Player ${player}'s deck shuffled`, 'success');
}
shuffleDeckWithAnimation = autoSync(shuffleDeckWithAnimation);

function openFromDeck(player) {
    if (decks[player].length === 0) {
        showNotification("Deck Empty", "No cards in deck!", 'warning');
        return;
    }
    
    const cardData = decks[player].shift();
    createBoardCard(cardData, player);
    updateCounters();
    updateDeckVisual(player);
    
    showNotification("Card Opened", `Player ${player} opened a card`, 'success');
}
openFromDeck = autoSync(openFromDeck);

function createBoardCard(cardData, player) {
    const cardId = cardData.id || `board_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const boardCard = document.createElement("div");
    boardCard.className = "board-card";
    boardCard.id = cardId;
    boardCard.style.backgroundImage = `url('${cardData.image}')`;
    
    if (cardData.color) {
        boardCard.style.borderColor = cardData.color;
        boardCard.style.borderWidth = "3px";
    }
    
    const playerArea = document.getElementById(`player${player}Area`);
    const rect = playerArea.getBoundingClientRect();
    
    const x = 150 + Math.random() * 50;
    const y = Math.random() * (rect.height - 180);
    
    boardCard.style.left = `${x}px`;
    boardCard.style.top = `${y}px`;
    
    if (player === multiplayer.playerNumber) {
        boardCard.addEventListener('mousedown', startDrag);
        boardCard.addEventListener('click', (e) => {
            e.stopPropagation();
            showCardZoom(cardData.image, { 
                type: 'board', 
                player: player, 
                cardId: cardId 
            });
        });
    } else {
        boardCard.style.cursor = 'default';
        boardCard.title = "Opponent's card";
        boardCard.addEventListener('click', (e) => {
            e.stopPropagation();
            showCardZoom(cardData.image, { 
                type: 'board', 
                player: player, 
                cardId: cardId,
                isOpponent: true 
            });
        });
    }
    
    playerArea.appendChild(boardCard);
    
    boardCards.push({
        id: cardId,
        image: cardData.image,
        player: player,
        element: boardCard,
        color: cardData.color,
        rotated: false
    });
}
createBoardCard = autoSync(createBoardCard);

function showCardZoom(image, source) {
    currentZoomImage = image;
    currentZoomSource = source;

    document.getElementById("zoomCard").style.backgroundImage = `url('${image}')`;
    
    const isShop = (source.type === 'shop');
    const isHand = (source.type === 'hand');
    const isBoard = (source.type === 'board');
    const isGraveyard = (source.type === 'graveyard');
    const isDeck = (source.type === 'deck');
    const isLifeZone = (source.type === 'lifezone');
    const isOpponent = source.isOpponent;
    
    document.getElementById("addToDeckP1").style.display = isShop ? "inline-block" : "none";
    document.getElementById("addToDeckP2").style.display = isShop ? "inline-block" : "none";
    document.getElementById("playToBoard").style.display = (isHand && !isOpponent) ? "inline-block" : "none";
    document.getElementById("moveToHand").style.display = (isBoard && !isOpponent) ? "inline-block" : "none";
    document.getElementById("moveToDeck").style.display = (isBoard && !isOpponent) ? "inline-block" : "none";
    document.getElementById("moveToGY").style.display = ((isHand || isBoard) && !isOpponent) ? "inline-block" : "none";
    document.getElementById("putToBoardFromGY").style.display = isGraveyard ? "inline-block" : "none";
    document.getElementById("putToBoardFromDeck").style.display = isDeck ? "inline-block" : "none";
    
    document.getElementById("rotateCardBtn").style.display = (isBoard && !isOpponent) ? "inline-block" : "none";
    document.getElementById("removeFromLifeZone").style.display = (isLifeZone && !isOpponent) ? "inline-block" : "none";
    document.getElementById("flipLifeZoneCard").style.display = (isLifeZone && !isOpponent) ? "inline-block" : "none";
    document.getElementById("deleteCardBtn").style.display = (isBoard && !isOpponent) ? "inline-block" : "none";
    
    document.getElementById("zoomOverlay").style.display = "flex";
}

function closeZoomOnly() { 
    document.getElementById("zoomOverlay").style.display = "none"; 
    currentZoomSource = null;
    cardToDelete = null;
}

function playToBoard() {
    if (!currentZoomSource || currentZoomSource.type !== 'hand') return;
    
    const player = currentZoomSource.player;
    const cardId = currentZoomSource.cardId;
    
    const cardIndex = hands[player].findIndex(card => card.id === cardId);
    if (cardIndex > -1) {
        const cardData = hands[player][cardIndex];
        hands[player].splice(cardIndex, 1);
        createBoardCard(cardData, player);
        updateCounters();
        closeZoomOnly();
        showNotification("Card Played", `Card played to board`, 'success');
    }
}
playToBoard = autoSync(playToBoard);

function moveToHand() {
    if (!currentZoomSource || currentZoomSource.type !== 'board') return;
    
    const player = currentZoomSource.player;
    const cardId = currentZoomSource.cardId;
    
    const cardIndex = boardCards.findIndex(card => card.id === cardId);
    if (cardIndex > -1) {
        const cardData = boardCards[cardIndex];
        boardCards.splice(cardIndex, 1);
        document.getElementById(cardId)?.remove();
        hands[player].push(cardData);
        updateCounters();
        closeZoomOnly();
        showNotification("Card Returned", `Card returned to hand`, 'info');
    }
}
moveToHand = autoSync(moveToHand);

function moveToGY() {
    if (!currentZoomSource) return;
    
    const player = currentZoomSource.player;
    const cardId = currentZoomSource.cardId;
    const sourceType = currentZoomSource.type;
    
    let cardData = null;
    
    if (sourceType === 'hand') {
        const cardIndex = hands[player].findIndex(card => card.id === cardId);
        if (cardIndex > -1) {
            cardData = hands[player][cardIndex];
            hands[player].splice(cardIndex, 1);
        }
    } else if (sourceType === 'board') {
        const cardIndex = boardCards.findIndex(card => card.id === cardId);
        if (cardIndex > -1) {
            cardData = boardCards[cardIndex];
            boardCards.splice(cardIndex, 1);
            document.getElementById(cardId)?.remove();
        }
    }
    
    if (cardData) {
        graveyards[player].push(cardData);
        updateCounters();
        closeZoomOnly();
        showNotification("Card Sent", `Card sent to graveyard`, 'info');
    }
}
moveToGY = autoSync(moveToGY);

function addToDeck(player) {
    if (currentZoomImage) {
        const cardId = `card_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        let categoryColor = "#555";
        for (const [categoryId, category] of Object.entries(CARD_CATEGORIES)) {
            if (currentZoomImage.includes(category.prefix)) {
                categoryColor = category.color;
                break;
            }
        }
        
        decks[player].push({ 
            image: currentZoomImage, 
            id: cardId,
            color: categoryColor
        });
        updateCounters();
        updateDeckVisual(player);
        closeZoomOnly();
        showNotification("Card Added", `Card added to deck`, 'success');
    }
}
addToDeck = autoSync(addToDeck);

function updateCounters() {
    document.getElementById("handCount1").textContent = hands[1].length;
    document.getElementById("handCount2").textContent = hands[2].length;
    document.getElementById("gyCount1").textContent = graveyards[1].length;
    document.getElementById("gyCount2").textContent = graveyards[2].length;
    updateDeckVisual(1);
    updateDeckVisual(2);
}
updateCounters = autoSync(updateCounters);

// ============================================================================
// SHOP FUNCTIONS
// ============================================================================
function setupShop() {
    const container = document.getElementById("shopCards");
    allShopCards = [];
    
    for (const [categoryId, category] of Object.entries(CARD_CATEGORIES)) {
        for (let i = 1; i <= category.count; i++) {
            const imgUrl = `${category.folder}${i}${category.prefix}${IMAGE_EXT}`;
            
            allShopCards.push({
                image: imgUrl,
                category: categoryId,
                categoryName: category.name,
                color: category.color
            });
        }
    }
    
    filterShopCards('all');
}

function filterShopCards(category, event) {
    currentShopCategory = category;
    
    document.querySelectorAll('.category-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    if (event && event.target) {
        event.target.classList.add('active');
    } else {
        document.querySelector('.category-btn').classList.add('active');
    }
    
    const lifeButtons = document.getElementById('lifeCategoryButtons');
    if (category === 'life') {
        lifeButtons.style.display = 'flex';
    } else {
        lifeButtons.style.display = 'none';
    }
    
    const container = document.getElementById("shopCards");
    container.innerHTML = "";
    
    const filteredCards = category === 'all' 
        ? allShopCards 
        : allShopCards.filter(card => card.category === category);
    
    filteredCards.forEach(cardData => {
        const card = document.createElement("div");
        card.className = "hand-display-card shop-card";
        
        const img = new Image();
        img.onload = function() {
            card.style.backgroundImage = `url('${cardData.image}')`;
        };
        img.onerror = function() {
            card.style.backgroundColor = cardData.color;
        };
        img.src = cardData.image;
        
        card.style.borderColor = cardData.color;
        card.style.borderWidth = "3px";
        
        const badge = document.createElement("div");
        badge.style.position = "absolute";
        badge.style.top = "5px";
        badge.style.right = "5px";
        badge.style.background = cardData.color;
        badge.style.color = "white";
        badge.style.padding = "2px 6px";
        badge.style.borderRadius = "10px";
        badge.style.fontSize = "10px";
        badge.style.fontWeight = "bold";
        badge.textContent = cardData.categoryName.charAt(0);
        card.appendChild(badge);
        
        card.title = `${cardData.categoryName}\nClick to add to deck`;
        
        if (category === 'life') {
            card.onclick = () => {
                currentShopImage = cardData.image;
                document.querySelectorAll('.shop-card').forEach(c => {
                    c.style.boxShadow = 'none';
                });
                card.style.boxShadow = '0 0 10px #7ED321';
                showNotification("Card Selected", `Selected ${cardData.categoryName} card. Now click "Add to P1 Life Zone" or "Add to P2 Life Zone"`, 'info', 3000);
            };
        } else {
            card.onclick = () => openQuantitySelector(cardData.image, cardData.category);
        }
        
        container.appendChild(card);
    });
}

function openShop() {
    document.getElementById("shopOverlay").style.display = "flex";
    currentShopImage = null;
    document.querySelectorAll('.shop-card').forEach(c => {
        c.style.boxShadow = 'none';
    });
}

function closeShop() {
    document.getElementById("shopOverlay").style.display = "none";
}

function openQuantitySelector(image, category) {
    quantitySelectorState = {
        image: image,
        category: category,
        quantity: 1
    };
    
    document.getElementById('quantityCardPreview').style.backgroundImage = `url('${image}')`;
    document.getElementById('quantityDisplay').textContent = '1';
    document.getElementById('quantityOverlay').style.display = 'flex';
}

function changeQuantity(amount) {
    const newQty = quantitySelectorState.quantity + amount;
    if (newQty >= 1 && newQty <= 99) {
        quantitySelectorState.quantity = newQty;
        document.getElementById('quantityDisplay').textContent = newQty;
    }
}

function closeQuantitySelector() {
    document.getElementById('quantityOverlay').style.display = 'none';
}

function addMultipleToDeck(player) {
    const { image, quantity } = quantitySelectorState;
    
    if (image && quantity > 0) {
        let categoryColor = "#555";
        for (const [categoryId, category] of Object.entries(CARD_CATEGORIES)) {
            if (image.includes(category.prefix)) {
                categoryColor = category.color;
                break;
            }
        }
        
        for (let i = 0; i < quantity; i++) {
            const cardId = `card_${Date.now()}_${Math.random().toString(36).substr(2, 9)}_${i}`;
            decks[player].push({ 
                image: image, 
                id: cardId,
                color: categoryColor
            });
        }
        
        updateCounters();
        updateDeckVisual(player);
        closeQuantitySelector();
        
        showNotification("Cards Added to Deck", `${quantity} card(s) added to Player ${player}'s deck!`, 'success', 3000);
    }
}

// ============================================================================
// DRAG AND DROP
// ============================================================================
function startDrag(e) {
    const card = e.target;
    if (!card.classList.contains('board-card')) return;
    
    const cardId = card.id;
    const cardData = boardCards.find(c => c.id === cardId);
    if (!cardData || cardData.player !== multiplayer.playerNumber) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    dragState.mouseDownTime = Date.now();
    dragState.startX = e.clientX;
    dragState.startY = e.clientY;
    
    dragState.originalCard = card;
    dragState.originalParent = card.parentElement;
    dragState.originalLeft = parseFloat(card.style.left) || 0;
    dragState.originalTop = parseFloat(card.style.top) || 0;
    dragState.draggingToken = false;
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
}

function handleMouseMove(e) {
    if (!dragState.originalCard) return;
    
    const currentTime = Date.now();
    const timeDiff = currentTime - dragState.mouseDownTime;
    const distanceX = Math.abs(e.clientX - dragState.startX);
    const distanceY = Math.abs(e.clientY - dragState.startY);
    
    if (!dragState.isDragging && (timeDiff > 50 || distanceX > 5 || distanceY > 5)) {
        dragState.isDragging = true;
        
        dragState.card = dragState.originalCard.cloneNode(true);
        dragState.card.classList.add('dragging');
        dragState.card.style.left = `${e.clientX - 60}px`;
        dragState.card.style.top = `${e.clientY - 90}px`;
        document.body.appendChild(dragState.card);
        
        dragState.originalCard.style.visibility = "hidden";
    }
    
    if (dragState.isDragging && dragState.card) {
        dragState.card.style.left = `${e.clientX - 60}px`;
        dragState.card.style.top = `${e.clientY - 90}px`;
    }
}

function handleMouseUp(e) {
    if (dragState.isDragging && !dragState.draggingToken) {
        const playerArea = dragState.originalParent;
        const rect = playerArea.getBoundingClientRect();
        
        const relativeX = e.clientX - rect.left - 60;
        const relativeY = e.clientY - rect.top - 90;
        
        const boundedX = Math.max(0, Math.min(relativeX, rect.width - 120));
        const boundedY = Math.max(0, Math.min(relativeY, rect.height - 180));
        
        dragState.originalCard.style.left = `${boundedX}px`;
        dragState.originalCard.style.top = `${boundedY}px`;
        dragState.originalCard.style.visibility = "visible";
        
        if (dragState.card) {
            dragState.card.remove();
        }
        
        const cardId = dragState.originalCard.id;
        const cardIndex = boardCards.findIndex(c => c.id === cardId);
        if (cardIndex > -1) {
            boardCards[cardIndex].element = dragState.originalCard;
        }
        
        if (multiplayer.gameId) {
            setTimeout(() => {
                syncGameStateToFirebase();
            }, 100);
        }
    }
    
    dragState.isDragging = false;
    dragState.card = null;
    dragState.originalCard = null;
    dragState.draggingToken = false;
    
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
}

// ============================================================================
// TOKEN FUNCTIONS
// ============================================================================
function addTokenToPlayer(player) {
    if (player !== multiplayer.playerNumber) return;
    
    const playerArea = document.getElementById(`player${player}Area`);
    const tokenCount = counterTokens[player].length;
    
    if (tokenCount >= 4) {
        showNotification("Token Limit", "Maximum 4 tokens per player", 'warning');
        return;
    }
    
    const tokenId = `token_${player}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const tokenColor = TOKEN_COLORS[player][tokenCount];
    const tokenLabel = TOKEN_LABELS[tokenCount] || `Token ${tokenCount + 1}`;
    
    const token = document.createElement("div");
    token.className = `counter-token token-p${player}-${tokenCount + 1}`;
    token.id = tokenId;
    
    const rect = playerArea.getBoundingClientRect();
    const col = tokenCount % 2;
    const row = Math.floor(tokenCount / 2);
    const x = rect.width - 120 + (col * 60);
    const y = rect.height - 120 + (row * 60);
    
    token.style.left = `${x}px`;
    token.style.top = `${y}px`;
    
    token.innerHTML = `
        <div class="counter-value">0</div>
        <div class="counter-label">${tokenLabel}</div>
        <div class="counter-controls">
            <button class="counter-btn minus" onclick="changeTokenValue('${tokenId}', -1)">-</button>
            <button class="counter-btn plus" onclick="changeTokenValue('${tokenId}', 1)">+</button>
        </div>
    `;
    
    token.addEventListener('mousedown', startTokenDrag);
    playerArea.appendChild(token);
    
    counterTokens[player].push({
        id: tokenId,
        player: player,
        value: 0,
        label: tokenLabel,
        color: tokenColor,
        element: token,
        position: { x, y }
    });
    
    showNotification("Token Added", `${tokenLabel} token added`, 'success');
}
addTokenToPlayer = autoSync(addTokenToPlayer);

function changeTokenValue(tokenId, amount) {
    event.stopPropagation();
    
    for (const player of [1, 2]) {
        const tokenIndex = counterTokens[player].findIndex(token => token.id === tokenId);
        if (tokenIndex > -1) {
            if (player !== multiplayer.playerNumber) return;
            
            const token = counterTokens[player][tokenIndex];
            const newValue = token.value + amount;
            token.value = newValue;
            
            const valueElement = token.element.querySelector('.counter-value');
            if (valueElement) {
                valueElement.textContent = newValue;
            }
            
            if (multiplayer.gameId) {
                setTimeout(() => {
                    syncGameStateToFirebase();
                }, 100);
            }
            break;
        }
    }
}
changeTokenValue = autoSync(changeTokenValue);

function resetPlayerTokens(player) {
    if (player !== multiplayer.playerNumber) return;
    
    counterTokens[player].forEach(token => {
        if (token.element && token.element.parentElement) {
            token.element.remove();
        }
    });
    
    counterTokens[player] = [];
    showNotification("Tokens Reset", `Player ${player}'s tokens have been reset!`, 'info', 3000);
}
resetPlayerTokens = autoSync(resetPlayerTokens);

function startTokenDrag(e) {
    const token = e.target.closest('.counter-token');
    if (!token) return;
    
    const tokenId = token.id;
    let ourToken = false;
    for (const player of [1, 2]) {
        const tokenIndex = counterTokens[player].findIndex(t => t.id === tokenId);
        if (tokenIndex > -1 && player === multiplayer.playerNumber) {
            ourToken = true;
            break;
        }
    }
    
    if (!ourToken) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    dragState.mouseDownTime = Date.now();
    dragState.startX = e.clientX;
    dragState.startY = e.clientY;
    
    dragState.originalCard = token;
    dragState.originalParent = token.parentElement;
    dragState.originalLeft = parseFloat(token.style.left) || 0;
    dragState.originalTop = parseFloat(token.style.top) || 0;
    dragState.draggingToken = true;
    
    document.addEventListener('mousemove', handleTokenMouseMove);
    document.addEventListener('mouseup', handleTokenMouseUp);
}

function handleTokenMouseMove(e) {
    if (!dragState.originalCard || !dragState.draggingToken) return;
    
    const currentTime = Date.now();
    const timeDiff = currentTime - dragState.mouseDownTime;
    const distanceX = Math.abs(e.clientX - dragState.startX);
    const distanceY = Math.abs(e.clientY - dragState.startY);
    
    if (!dragState.isDragging && (timeDiff > 50 || distanceX > 5 || distanceY > 5)) {
        dragState.isDragging = true;
        
        dragState.card = dragState.originalCard.cloneNode(true);
        dragState.card.classList.add('dragging');
        dragState.card.style.width = "50px";
        dragState.card.style.height = "50px";
        dragState.card.style.left = `${e.clientX - 25}px`;
        dragState.card.style.top = `${e.clientY - 25}px`;
        document.body.appendChild(dragState.card);
        
        dragState.originalCard.style.visibility = "hidden";
    }
    
    if (dragState.isDragging && dragState.card) {
        dragState.card.style.left = `${e.clientX - 25}px`;
        dragState.card.style.top = `${e.clientY - 25}px`;
    }
}

function handleTokenMouseUp(e) {
    if (dragState.isDragging && dragState.draggingToken) {
        const playerArea = dragState.originalParent;
        const rect = playerArea.getBoundingClientRect();
        
        const relativeX = e.clientX - rect.left - 25;
        const relativeY = e.clientY - rect.top - 25;
        
        const boundedX = Math.max(0, Math.min(relativeX, rect.width - 50));
        const boundedY = Math.max(0, Math.min(relativeY, rect.height - 50));
        
        dragState.originalCard.style.left = `${boundedX}px`;
        dragState.originalCard.style.top = `${boundedY}px`;
        dragState.originalCard.style.visibility = "visible";
        
        if (dragState.card) {
            dragState.card.remove();
        }
        
        const tokenId = dragState.originalCard.id;
        for (const player of [1, 2]) {
            const tokenIndex = counterTokens[player].findIndex(token => token.id === tokenId);
            if (tokenIndex > -1) {
                counterTokens[player][tokenIndex].position = { x: boundedX, y: boundedY };
                break;
            }
        }
        
        if (multiplayer.gameId) {
            setTimeout(() => {
                syncGameStateToFirebase();
            }, 100);
        }
    }
    
    dragState.isDragging = false;
    dragState.card = null;
    dragState.originalCard = null;
    dragState.draggingToken = false;
    
    document.removeEventListener('mousemove', handleTokenMouseMove);
    document.removeEventListener('mouseup', handleTokenMouseUp);
}

// ============================================================================
// LIFE ZONE FUNCTIONS
// ============================================================================
function initializeLifeZones() {
    for (let player of [1, 2]) {
        const container = document.getElementById(`lifeZones${player}`);
        container.innerHTML = '';
        
        for (let i = 0; i < 5; i++) {
            const zone = document.createElement('div');
            zone.className = 'life-zone';
            zone.id = `lifeZone_${player}_${i}`;
            zone.setAttribute('data-player', player);
            zone.setAttribute('data-index', i);
            
            const number = document.createElement('div');
            number.className = 'life-zone-number';
            number.textContent = `L${i + 1}`;
            zone.appendChild(number);
            
            zone.addEventListener('dragover', handleLifeZoneDragOver);
            zone.addEventListener('drop', handleLifeZoneDrop);
            
            container.appendChild(zone);
        }
    }
}

function handleLifeZoneDragOver(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (dragState.isDragging && !dragState.draggingToken) {
        e.currentTarget.style.borderColor = '#9fea5f';
        e.currentTarget.style.boxShadow = '0 0 10px rgba(126, 211, 33, 0.5)';
    }
}

function handleLifeZoneDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (!dragState.isDragging || dragState.draggingToken) return;
    
    const zone = e.currentTarget;
    const player = parseInt(zone.getAttribute('data-player'));
    const index = parseInt(zone.getAttribute('data-index'));
    
    zone.style.borderColor = '';
    zone.style.boxShadow = '';
    
    if (dragState.originalCard && dragState.originalCard.classList.contains('board-card')) {
        const cardId = dragState.originalCard.id;
        const cardIndex = boardCards.findIndex(card => card.id === cardId);
        
        if (cardIndex > -1) {
            const cardData = boardCards[cardIndex];
            
            if (lifeZones[player][index]) {
                returnCardFromLifeZone(player, index);
            }
            
            boardCards.splice(cardIndex, 1);
            dragState.originalCard.remove();
            
            lifeZones[player][index] = {
                ...cardData,
                flipped: false
            };
            updateLifeZoneDisplay(player, index, lifeZones[player][index], player !== multiplayer.playerNumber);
            
            showNotification("Card Added to Life Zone", `Card added to Life Zone ${index + 1} for Player ${player}`, 'success', 3000);
            return;
        }
    }
    
    if (currentZoomSource && currentZoomSource.type === 'hand') {
        const player = currentZoomSource.player;
        const cardId = currentZoomSource.cardId;
        const cardIndex = hands[player].findIndex(card => card.id === cardId);
        
        if (cardIndex > -1) {
            const cardData = hands[player][cardIndex];
            
            if (lifeZones[player][index]) {
                showNotification("Life Zone Full", `Life Zone ${index + 1} already has a card!`, 'warning', 3000);
                return;
            }
            
            hands[player].splice(cardIndex, 1);
            
            lifeZones[player][index] = {
                ...cardData,
                flipped: false
            };
            updateLifeZoneDisplay(player, index, lifeZones[player][index], player !== multiplayer.playerNumber);
            
            updateCounters();
            closeZoomOnly();
            
            showNotification("Card Added to Life Zone", `Card added to Life Zone ${index + 1} for Player ${player}`, 'success', 3000);
            return;
        }
    }
}

function updateLifeZoneDisplay(player, index, cardData, isOpponent = false) {
    const zone = document.getElementById(`lifeZone_${player}_${index}`);
    if (!zone) return;
    
    zone.innerHTML = '';
    
    const number = document.createElement('div');
    number.className = 'life-zone-number';
    number.textContent = `L${index + 1}`;
    zone.appendChild(number);
    
    if (cardData) {
        zone.classList.add('has-card');
        
        const cardDisplay = document.createElement('div');
        cardDisplay.className = 'life-zone-card';
        
        if (cardData.flipped) {
            cardDisplay.classList.add('flipped');
        } else {
            cardDisplay.style.backgroundImage = `url('${cardData.image}')`;
        }
        
        if (isOpponent) {
            cardDisplay.title = "Opponent's card";
            cardDisplay.style.cursor = 'default';
        } else {
            cardDisplay.title = `Life Zone ${index + 1}: Click to view`;
            cardDisplay.style.cursor = 'pointer';
        }
        
        if (!isOpponent) {
            cardDisplay.onclick = (e) => {
                e.stopPropagation();
                if (cardData.flipped) {
                    showCardZoom(cardData.image, {
                        type: 'lifezone',
                        player: player,
                        zoneIndex: index,
                        cardId: cardData.id,
                        flipped: true
                    });
                } else {
                    showCardZoom(cardData.image, {
                        type: 'lifezone',
                        player: player,
                        zoneIndex: index,
                        cardId: cardData.id,
                        flipped: false
                    });
                }
            };
        }
        
        zone.appendChild(cardDisplay);
        
        if (!isOpponent) {
            const flipBtn = document.createElement('button');
            flipBtn.className = 'life-zone-flip-btn';
            flipBtn.innerHTML = '‚Üª';
            flipBtn.title = 'Flip card';
            flipBtn.onclick = (e) => {
                e.stopPropagation();
                flipLifeZoneCardDirect(player, index);
            };
            zone.appendChild(flipBtn);
        }
        
    } else {
        zone.classList.remove('has-card');
    }
}

function returnCardFromLifeZone(player, index) {
    const cardData = lifeZones[player][index];
    if (!cardData) return;
    
    const cardDataForBoard = { ...cardData, flipped: false, rotated: false };
    createBoardCard(cardDataForBoard, player);
    lifeZones[player][index] = null;
    updateLifeZoneDisplay(player, index, null, player !== multiplayer.playerNumber);
    
    showNotification("Card Returned to Board", `Card returned from Life Zone ${index + 1} to board`, 'info', 3000);
}
returnCardFromLifeZone = autoSync(returnCardFromLifeZone);

function shuffleLifeZones(player) {
    if (player !== multiplayer.playerNumber) return;
    
    const zones = lifeZones[player];
    const cards = zones.filter(card => card !== null);
    
    if (cards.length <= 1) {
        showNotification("Not Enough Cards", `Player ${player} needs at least 2 cards in life zones to shuffle!`, 'warning', 3000);
        return;
    }
    
    for (let i = cards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [cards[i], cards[j]] = [cards[j], cards[i]];
    }
    
    let cardIndex = 0;
    for (let i = 0; i < zones.length; i++) {
        if (zones[i] !== null) {
            lifeZones[player][i] = cards[cardIndex];
            updateLifeZoneDisplay(player, i, cards[cardIndex], player !== multiplayer.playerNumber);
            cardIndex++;
        }
    }
    
    showNotification("Life Zones Shuffled", `Player ${player}'s life zones have been shuffled!`, 'success', 3000);
}
shuffleLifeZones = autoSync(shuffleLifeZones);

function removeFromLifeZone() {
    if (!currentZoomSource || currentZoomSource.type !== 'lifezone') return;
    
    const player = currentZoomSource.player;
    const zoneIndex = currentZoomSource.zoneIndex;
    
    const cardData = lifeZones[player][zoneIndex];
    if (cardData) {
        setTimeout(() => {
            const userChoice = confirm(`Remove card from Life Zone ${zoneIndex + 1}.\nOK = Put in hand\nCancel = Put on board`);
            
            if (userChoice) {
                hands[player].push({...cardData, flipped: false, rotated: false});
                showNotification("Card Moved to Hand", `Card moved from Life Zone ${zoneIndex + 1} to hand`, 'success', 2000);
            } else {
                createBoardCard({...cardData, flipped: false, rotated: false}, player);
                showNotification("Card Moved to Board", `Card moved from Life Zone ${zoneIndex + 1} to board`, 'success', 2000);
            }
            
            lifeZones[player][zoneIndex] = null;
            updateLifeZoneDisplay(player, zoneIndex, null, player !== multiplayer.playerNumber);
            updateCounters();
            closeZoomOnly();
        }, 100);
    }
}
removeFromLifeZone = autoSync(removeFromLifeZone);

function flipLifeZoneCard() {
    if (!currentZoomSource || currentZoomSource.type !== 'lifezone') return;
    
    const player = currentZoomSource.player;
    const zoneIndex = currentZoomSource.zoneIndex;
    
    const cardData = lifeZones[player][zoneIndex];
    if (cardData) {
        cardData.flipped = !cardData.flipped;
        updateLifeZoneDisplay(player, zoneIndex, cardData, player !== multiplayer.playerNumber);
        closeZoomOnly();
        
        const status = cardData.flipped ? "flipped face-down" : "flipped face-up";
        showNotification("Card Flipped", `Life Zone ${zoneIndex + 1} card ${status}`, 'info', 2000);
    }
}
flipLifeZoneCard = autoSync(flipLifeZoneCard);

function addToLifeZone(player) {
    if (!currentShopImage) {
        showNotification("No Card Selected", "Please select a card first!", 'warning', 3000);
        return;
    }
    
    const emptyIndex = lifeZones[player].findIndex(card => card === null);
    
    if (emptyIndex === -1) {
        showNotification("Life Zones Full", `Player ${player} has no empty life zones!`, 'warning', 3000);
        return;
    }
    
    const cardId = `life_${player}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    let categoryColor = "#7ED321";
    for (const [categoryId, category] of Object.entries(CARD_CATEGORIES)) {
        if (currentShopImage.includes(category.prefix)) {
            categoryColor = category.color;
            break;
        }
    }
    
    const cardData = {
        image: currentShopImage,
        id: cardId,
        color: categoryColor,
        flipped: false
    };
    
    lifeZones[player][emptyIndex] = cardData;
    updateLifeZoneDisplay(player, emptyIndex, cardData, player !== multiplayer.playerNumber);
    
    showNotification("Card Added to Life Zone", `Card added to Life Zone ${emptyIndex + 1} for Player ${player}`, 'success', 3000);
    currentShopImage = null;
}
addToLifeZone = autoSync(addToLifeZone);

// ============================================================================
// VIEW FUNCTIONS
// ============================================================================
function viewHand(player) {
    const overlay = document.getElementById("handOverlay");
    const container = document.getElementById("handCardsContainer");
    document.getElementById("handTitle").textContent = `Player ${player}'s Hand (${hands[player].length} Cards)`;
    container.innerHTML = "";

    hands[player].forEach(cardData => {
        const card = document.createElement("div");
        card.className = "hand-display-card";
        
        const img = new Image();
        img.onload = function() {
            card.style.backgroundImage = `url('${cardData.image}')`;
        };
        img.onerror = function() {
            card.style.backgroundColor = cardData.color || "#555";
        };
        img.src = cardData.image;
        
        if (cardData.color) {
            card.style.borderColor = cardData.color;
            card.style.borderWidth = "3px";
        }
        
        card.onclick = () => showCardZoom(cardData.image, { 
            type: 'hand', 
            player: player, 
            cardId: cardData.id 
        });
        container.appendChild(card);
    });

    overlay.style.display = "flex";
}

function closeHand() { 
    document.getElementById("handOverlay").style.display = "none"; 
}

function viewDeck(player) {
    const overlay = document.getElementById("deckOverlay");
    const container = document.getElementById("deckCardsContainer");
    document.getElementById("deckTitle").textContent = `Player ${player}'s Deck (${decks[player].length} Cards)`;
    container.innerHTML = "";

    decks[player].forEach((cardData, index) => {
        const card = document.createElement("div");
        card.className = "hand-display-card deck-card";
        
        const img = new Image();
        img.onload = function() {
            card.style.backgroundImage = `url('${cardData.image}')`;
        };
        img.onerror = function() {
            card.style.backgroundColor = cardData.color || "#555";
        };
        img.src = cardData.image;
        
        if (cardData.color) {
            card.style.borderColor = cardData.color;
            card.style.borderWidth = "3px";
        }
        
        const positionBadge = document.createElement("div");
        positionBadge.style.position = "absolute";
        positionBadge.style.top = "5px";
        positionBadge.style.left = "5px";
        positionBadge.style.background = "rgba(0,0,0,0.7)";
        positionBadge.style.color = "white";
        positionBadge.style.padding = "2px 6px";
        positionBadge.style.borderRadius = "10px";
        positionBadge.style.fontSize = "10px";
        positionBadge.style.fontWeight = "bold";
        positionBadge.textContent = `#${index + 1}`;
        card.appendChild(positionBadge);
        
        card.onclick = () => {
            showCardZoom(cardData.image, { 
                type: 'deck', 
                player: player, 
                cardIndex: index 
            });
        };
        
        container.appendChild(card);
    });

    overlay.style.display = "flex";
}

function closeDeck() { 
    document.getElementById("deckOverlay").style.display = "none"; 
}

function viewGraveyard(player) {
    const overlay = document.getElementById("graveyardOverlay");
    const container = document.getElementById("graveyardCardsContainer");
    document.getElementById("graveyardTitle").textContent = `Player ${player}'s Graveyard (${graveyards[player].length} Cards)`;
    container.innerHTML = "";

    graveyards[player].forEach((cardData, index) => {
        const card = document.createElement("div");
        card.className = "hand-display-card gy-card";
        
        const img = new Image();
        img.onload = function() {
            card.style.backgroundImage = `url('${cardData.image}')`;
        };
        img.onerror = function() {
            card.style.backgroundColor = cardData.color || "#555";
        };
        img.src = cardData.image;
        
        if (cardData.color) {
            card.style.borderColor = cardData.color;
            card.style.borderWidth = "3px";
        }
        
        card.onclick = () => {
            showCardZoom(cardData.image, { 
                type: 'graveyard', 
                player: player, 
                cardIndex: index 
            });
        };
        
        container.appendChild(card);
    });

    overlay.style.display = "flex";
}

function closeGraveyard() { 
    document.getElementById("graveyardOverlay").style.display = "none"; 
}

// ============================================================================
// OTHER FUNCTIONS
// ============================================================================
function rotateCard() {
    if (!currentZoomSource || currentZoomSource.type !== 'board') return;
    
    const cardId = currentZoomSource.cardId;
    const cardElement = document.getElementById(cardId);
    if (cardElement) {
        rotateCardDirect(cardElement);
        closeZoomOnly();
    }
}

function rotateCardDirect(cardElement) {
    if (!cardElement) return;
    
    cardElement.classList.toggle('rotated');
    
    const cardIndex = boardCards.findIndex(c => c.element === cardElement);
    if (cardIndex > -1) {
        boardCards[cardIndex].rotated = !boardCards[cardIndex].rotated;
    }
}
rotateCard = autoSync(rotateCard);
rotateCardDirect = autoSync(rotateCardDirect);

function showDeleteConfirmation() {
    if (!currentZoomSource || currentZoomSource.type !== 'board') return;
    
    const cardId = currentZoomSource.cardId;
    const cardElement = document.getElementById(cardId);
    
    if (cardElement) {
        cardToDelete = cardId;
        document.getElementById('confirmDeleteOverlay').style.display = 'flex';
    }
}

function showDeleteConfirmationForCard(cardId) {
    const cardElement = document.getElementById(cardId);
    if (cardElement) {
        cardToDelete = cardId;
        document.getElementById('confirmDeleteOverlay').style.display = 'flex';
    }
}

function confirmDeleteCard() {
    if (!cardToDelete) {
        cancelDeleteCard();
        return;
    }
    
    const cardIndex = boardCards.findIndex(card => card.id === cardToDelete);
    
    if (cardIndex > -1) {
        const cardElement = document.getElementById(cardToDelete);
        
        if (cardElement) {
            cardElement.classList.add('delete-animation');
            
            setTimeout(() => {
                cardElement.remove();
                boardCards.splice(cardIndex, 1);
                document.getElementById('confirmDeleteOverlay').style.display = 'none';
                closeZoomOnly();
                showNotification("Card Deleted", "Card has been permanently deleted!", 'info', 3000);
            }, 500);
        }
    }
    
    cardToDelete = null;
}
confirmDeleteCard = autoSync(confirmDeleteCard);

function cancelDeleteCard() {
    cardToDelete = null;
    document.getElementById('confirmDeleteOverlay').style.display = 'none';
}

// ============================================================================
// INITIALIZATION
// ============================================================================
window.addEventListener('load', function() {
    const urlParams = new URLSearchParams(window.location.search);
    const gameCode = urlParams.get('game');
    
    if (gameCode && gameCode.length === 6) {
        document.getElementById('gameCodeInput').value = gameCode;
        showMultiplayerMenu();
        
        setTimeout(() => {
            if (database) {
                joinGame();
            }
        }, 500);
    }
    
    updateCounters();
    initializeLifeZones();
    setupShop();
});

// ============================================================================
// EVENT LISTENERS
// ============================================================================
document.getElementById("addToDeckP1").onclick = () => addToDeck(1);
document.getElementById("addToDeckP2").onclick = () => addToDeck(2);
document.getElementById("playToBoard").onclick = playToBoard;
document.getElementById("moveToHand").onclick = moveToHand;
document.getElementById("moveToGY").onclick = moveToGY;
document.getElementById('addToP1DeckQty').onclick = () => addMultipleToDeck(1);
document.getElementById('addToP2DeckQty').onclick = () => addMultipleToDeck(2);

// ============================================================================
// KEYBOARD SHORTCUTS
// ============================================================================
document.addEventListener('keydown', function(e) {
    if (dragState.isDragging && dragState.lastDraggedCard) {
        const cardId = dragState.lastDraggedCard.id;
        const cardIndex = boardCards.findIndex(c => c.id === cardId);
        
        if (cardIndex > -1) {
            const cardElement = boardCards[cardIndex].element;
            
            switch(e.key.toLowerCase()) {
                case 'r':
                    e.preventDefault();
                    rotateCardDirect(cardElement);
                    break;
                    
                case 'delete':
                case 'd':
                    e.preventDefault();
                    showDeleteConfirmationForCard(cardElement.id);
                    break;
                    
                case 'escape':
                    e.preventDefault();
                    dragState.isDragging = false;
                    if (dragState.card) dragState.card.remove();
                    if (dragState.originalCard) dragState.originalCard.style.visibility = "visible";
                    break;
            }
        }
    }
});

// ============================================================================
// ANIMATION STYLES
// ============================================================================
const style = document.createElement('style');
style.textContent = `
@keyframes shuffleSuccess {
    0% { box-shadow: 0 0 0 0 rgba(0, 170, 170, 0.7); }
    70% { box-shadow: 0 0 0 20px rgba(0, 170, 170, 0); }
    100% { box-shadow: 0 0 0 0 rgba(0, 170, 170, 0); }
}
`;
document.head.appendChild(style);
</script>
</body>
</html>
